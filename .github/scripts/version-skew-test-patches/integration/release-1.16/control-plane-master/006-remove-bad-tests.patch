diff --git a/tests/integration/suite/actors/actors.go b/tests/integration/suite/actors/actors.go
index 010e1d3fa..002a01708 100644
--- a/tests/integration/suite/actors/actors.go
+++ b/tests/integration/suite/actors/actors.go
@@ -21,7 +21,6 @@ import (
 	_ "github.com/dapr/dapr/tests/integration/suite/actors/http"
 	_ "github.com/dapr/dapr/tests/integration/suite/actors/lock"
 	_ "github.com/dapr/dapr/tests/integration/suite/actors/metadata"
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders"
 	_ "github.com/dapr/dapr/tests/integration/suite/actors/state"
 	_ "github.com/dapr/dapr/tests/integration/suite/actors/timers"
 )
diff --git a/tests/integration/suite/actors/reminders/basic.go b/tests/integration/suite/actors/reminders/basic.go
deleted file mode 100644
index ba52ca3de..000000000
--- a/tests/integration/suite/actors/reminders/basic.go
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"strings"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/credentials/insecure"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(basic))
-}
-
-// basic tests the basic functionality of actor reminders.
-type basic struct {
-	daprd *daprd.Daprd
-	place *placement.Placement
-
-	reminderCalled     atomic.Int64
-	stopReminderCalled atomic.Int64
-}
-
-func (b *basic) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false`), 0o600))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/remindermethod", func(w http.ResponseWriter, r *http.Request) {
-		b.reminderCalled.Add(1)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/stopreminder", func(w http.ResponseWriter, r *http.Request) {
-		b.stopReminderCalled.Add(1)
-		w.Header().Set("X-DaprReminderCancel", "true")
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	b.place = placement.New(t)
-	b.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(b.place.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(b.place, srv, b.daprd),
-	}
-}
-
-func (b *basic) Run(t *testing.T, ctx context.Context) {
-	b.place.WaitUntilRunning(t, ctx)
-	b.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://localhost:" + strconv.Itoa(b.daprd.HTTPPort()) + "/v1.0/actors/myactortype/myactorid"
-
-	t.Run("actor ready", func(t *testing.T) {
-		req, err := http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/method/foo", nil)
-		require.NoError(t, err)
-
-		require.EventuallyWithT(t, func(c *assert.CollectT) {
-			resp, rErr := client.Do(req)
-			if assert.NoError(c, rErr) {
-				assert.NoError(c, resp.Body.Close())
-				assert.Equal(c, http.StatusOK, resp.StatusCode)
-			}
-		}, 10*time.Second, 10*time.Millisecond, "actor not ready in time")
-	})
-	//nolint:staticcheck
-	conn, err := grpc.DialContext(ctx, b.daprd.GRPCAddress(),
-		grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock(), //nolint:staticcheck
-	)
-	require.NoError(t, err)
-	t.Cleanup(func() { require.NoError(t, conn.Close()) })
-	gclient := rtv1.NewDaprClient(conn)
-
-	t.Run("schedule reminder via HTTP", func(t *testing.T) {
-		const body = `{"dueTime": "0ms"}`
-		var (
-			req  *http.Request
-			resp *http.Response
-		)
-		req, err = http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/reminders/remindermethod", strings.NewReader(body))
-		require.NoError(t, err)
-
-		resp, err = client.Do(req)
-		require.NoError(t, err)
-		require.NoError(t, resp.Body.Close())
-		assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-
-		assert.Eventually(t, func() bool {
-			return b.reminderCalled.Load() == 1
-		}, 10*time.Second, 10*time.Millisecond)
-	})
-
-	t.Run("schedule reminder via gRPC", func(t *testing.T) {
-		_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      "remindermethod",
-			DueTime:   "0ms",
-		})
-		require.NoError(t, err)
-
-		assert.Eventually(t, func() bool {
-			return b.reminderCalled.Load() == 2
-		}, 10*time.Second, 10*time.Millisecond)
-	})
-
-	t.Run("cancel recurring reminder", func(t *testing.T) {
-		// Register a reminder that repeats every second
-		_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      "stopreminder",
-			DueTime:   "0s",
-			Period:    "1s",
-		})
-		require.NoError(t, err)
-
-		// Should be invoked once
-		assert.Eventually(t, func() bool {
-			return b.stopReminderCalled.Load() == 1
-		}, 10*time.Second, 10*time.Millisecond)
-
-		// After 2s, should not have been invoked more
-		time.Sleep(2 * time.Second)
-		assert.Equal(t, int64(1), b.stopReminderCalled.Load())
-	})
-}
diff --git a/tests/integration/suite/actors/reminders/data.go b/tests/integration/suite/actors/reminders/data.go
deleted file mode 100644
index a503de2e1..000000000
--- a/tests/integration/suite/actors/reminders/data.go
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(data))
-}
-
-type data struct {
-	actors *actors.Actors
-	got    chan string
-}
-
-func (d *data) Setup(t *testing.T) []framework.Option {
-	d.got = make(chan string, 1)
-	d.actors = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(_ http.ResponseWriter, req *http.Request) {
-			got, err := io.ReadAll(req.Body)
-			assert.NoError(t, err)
-			d.got <- string(got)
-		}),
-		actors.WithFeatureSchedulerReminders(false),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(d.actors),
-	}
-}
-
-func (d *data) Run(t *testing.T, ctx context.Context) {
-	d.actors.WaitUntilRunning(t, ctx)
-
-	_, err := d.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "foo",
-		ActorId:   "1234",
-		Name:      "helloworld",
-		DueTime:   "0s",
-		Period:    "1000s",
-		Ttl:       "2000s",
-		Data:      []byte("mydata"),
-	})
-	require.NoError(t, err)
-
-	select {
-	case got := <-d.got:
-		assert.JSONEq(t, `{"data":"bXlkYXRh","dueTime":"0s","period":"1000s"}`, got)
-	case <-time.After(10 * time.Second):
-		t.Fatal("timed out waiting for reminder")
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/duetime.go b/tests/integration/suite/actors/reminders/duetime.go
deleted file mode 100644
index a6a7e0e65..000000000
--- a/tests/integration/suite/actors/reminders/duetime.go
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
-Copyright 202d The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"net/http"
-	"strconv"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/credentials/insecure"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	procscheduler "github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(duetime))
-}
-
-type duetime struct {
-	daprd     *daprd.Daprd
-	place     *placement.Placement
-	scheduler *procscheduler.Scheduler
-
-	reminderCalled     atomic.Int64
-	stopReminderCalled atomic.Int64
-}
-
-func (d *duetime) Setup(t *testing.T) []framework.Option {
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/remindermethod", func(w http.ResponseWriter, r *http.Request) {
-		d.reminderCalled.Add(1)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/stopreminder", func(w http.ResponseWriter, r *http.Request) {
-		d.stopReminderCalled.Add(1)
-		w.Header().Set("X-DaprReminderCancel", "true")
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	d.scheduler = procscheduler.New(t)
-	d.place = placement.New(t)
-	d.daprd = daprd.New(t,
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithAppPort(srv.Port()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(d.scheduler, d.place, srv, d.daprd),
-	}
-}
-
-func (d *duetime) Run(t *testing.T, ctx context.Context) {
-	d.scheduler.WaitUntilRunning(t, ctx)
-	d.place.WaitUntilRunning(t, ctx)
-	d.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://localhost:" + strconv.Itoa(d.daprd.HTTPPort()) + "/v1.0/actors/myactortype/myactorid"
-
-	t.Run("actor ready", func(t *testing.T) {
-		req, err := http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/method/foo", nil)
-		require.NoError(t, err)
-
-		require.EventuallyWithT(t, func(c *assert.CollectT) {
-			resp, rErr := client.Do(req)
-			if assert.NoError(c, rErr) {
-				assert.NoError(c, resp.Body.Close())
-				assert.Equal(c, http.StatusOK, resp.StatusCode)
-			}
-		}, 10*time.Second, 10*time.Millisecond, "actor not ready in time")
-	})
-
-	//nolint:staticcheck
-	conn, err := grpc.DialContext(ctx, d.daprd.GRPCAddress(),
-		grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock(),
-	)
-	require.NoError(t, err)
-	t.Cleanup(func() { require.NoError(t, conn.Close()) })
-	gclient := rtv1.NewDaprClient(conn)
-
-	t.Run("schedule reminder via gRPC", func(t *testing.T) {
-		_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      "remindermethod",
-			DueTime:   "0s",
-			Period:    "PT1M",
-		})
-		require.NoError(t, err)
-
-		assert.Eventually(t, func() bool {
-			return d.reminderCalled.Load() == 1
-		}, 3*time.Second, 10*time.Millisecond)
-	})
-}
diff --git a/tests/integration/suite/actors/reminders/failurepolicy/failurepolicy.go b/tests/integration/suite/actors/reminders/failurepolicy/failurepolicy.go
deleted file mode 100644
index 98b1549af..000000000
--- a/tests/integration/suite/actors/reminders/failurepolicy/failurepolicy.go
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package failurepolicy
-
-import (
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/failurepolicy/noset"
-)
diff --git a/tests/integration/suite/actors/reminders/failurepolicy/noset/allfail.go b/tests/integration/suite/actors/reminders/failurepolicy/noset/allfail.go
deleted file mode 100644
index be6b23b16..000000000
--- a/tests/integration/suite/actors/reminders/failurepolicy/noset/allfail.go
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package noset
-
-import (
-	"context"
-	"net/http"
-	"path"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(allfail))
-}
-
-type allfail struct {
-	actors    *actors.Actors
-	triggered slice.Slice[string]
-}
-
-func (a *allfail) Setup(t *testing.T) []framework.Option {
-	a.triggered = slice.String()
-
-	a.actors = actors.New(t,
-		actors.WithActorTypes("helloworld"),
-		actors.WithActorTypeHandler("helloworld", func(w http.ResponseWriter, req *http.Request) {
-			if req.Method == http.MethodDelete {
-				return
-			}
-			a.triggered.Append(path.Base(req.URL.Path))
-			w.WriteHeader(http.StatusInternalServerError)
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(a.actors),
-	}
-}
-
-func (a *allfail) Run(t *testing.T, ctx context.Context) {
-	a.actors.WaitUntilRunning(t, ctx)
-
-	_, err := a.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "helloworld",
-		ActorId:   "1234",
-		Name:      "test",
-		DueTime:   "1s",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, []string{"test", "test", "test", "test"}, a.triggered.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	assert.ElementsMatch(t, []string{"test", "test", "test", "test"}, a.triggered.Slice())
-}
diff --git a/tests/integration/suite/actors/reminders/failurepolicy/noset/failfirst.go b/tests/integration/suite/actors/reminders/failurepolicy/noset/failfirst.go
deleted file mode 100644
index 0991bf31b..000000000
--- a/tests/integration/suite/actors/reminders/failurepolicy/noset/failfirst.go
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package noset
-
-import (
-	"context"
-	"net/http"
-	"path"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(failfirst))
-}
-
-type failfirst struct {
-	actors    *actors.Actors
-	triggered slice.Slice[string]
-	respErr   atomic.Bool
-}
-
-func (f *failfirst) Setup(t *testing.T) []framework.Option {
-	f.triggered = slice.String()
-	f.respErr.Store(true)
-
-	f.actors = actors.New(t,
-		actors.WithActorTypes("helloworld"),
-		actors.WithActorTypeHandler("helloworld", func(w http.ResponseWriter, req *http.Request) {
-			defer f.triggered.Append(path.Base(req.URL.Path))
-			if f.respErr.Load() {
-				w.WriteHeader(http.StatusInternalServerError)
-			}
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(f.actors),
-	}
-}
-
-func (f *failfirst) Run(t *testing.T, ctx context.Context) {
-	f.actors.WaitUntilRunning(t, ctx)
-
-	_, err := f.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "helloworld",
-		ActorId:   "1234",
-		Name:      "test",
-		DueTime:   "0s",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.GreaterOrEqual(c, f.triggered.Len(), 1)
-	}, time.Second*10, time.Millisecond*10)
-
-	f.respErr.Store(false)
-	count := f.triggered.Len()
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Equal(c, f.triggered.Len(), count+1)
-	}, time.Second*10, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	assert.Equal(t, f.triggered.Len(), count+1)
-}
diff --git a/tests/integration/suite/actors/reminders/failurepolicy/noset/failsecond.go b/tests/integration/suite/actors/reminders/failurepolicy/noset/failsecond.go
deleted file mode 100644
index b08bcc5d0..000000000
--- a/tests/integration/suite/actors/reminders/failurepolicy/noset/failsecond.go
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package noset
-
-import (
-	"context"
-	"net/http"
-	"path"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(failsecond))
-}
-
-type failsecond struct {
-	actors    *actors.Actors
-	triggered slice.Slice[string]
-	respErr   atomic.Bool
-}
-
-func (f *failsecond) Setup(t *testing.T) []framework.Option {
-	f.triggered = slice.String()
-	f.respErr.Store(true)
-
-	f.actors = actors.New(t,
-		actors.WithActorTypes("helloworld"),
-		actors.WithActorTypeHandler("helloworld", func(w http.ResponseWriter, req *http.Request) {
-			defer f.triggered.Append(path.Base(req.URL.Path))
-			if f.respErr.Load() {
-				w.WriteHeader(http.StatusInternalServerError)
-			}
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(f.actors),
-	}
-}
-
-func (f *failsecond) Run(t *testing.T, ctx context.Context) {
-	f.actors.WaitUntilRunning(t, ctx)
-
-	_, err := f.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "helloworld",
-		ActorId:   "1234",
-		Name:      "test",
-		DueTime:   "0s",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, []string{"test", "test"}, f.triggered.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	f.respErr.Store(false)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, []string{"test", "test", "test"}, f.triggered.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	assert.ElementsMatch(t, []string{"test", "test", "test"}, f.triggered.Slice())
-}
diff --git a/tests/integration/suite/actors/reminders/failurepolicy/noset/failthird.go b/tests/integration/suite/actors/reminders/failurepolicy/noset/failthird.go
deleted file mode 100644
index 40c623069..000000000
--- a/tests/integration/suite/actors/reminders/failurepolicy/noset/failthird.go
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package noset
-
-import (
-	"context"
-	"net/http"
-	"path"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(failthird))
-}
-
-type failthird struct {
-	actors    *actors.Actors
-	triggered slice.Slice[string]
-	respErr   atomic.Bool
-}
-
-func (f *failthird) Setup(t *testing.T) []framework.Option {
-	f.triggered = slice.String()
-	f.respErr.Store(true)
-
-	f.actors = actors.New(t,
-		actors.WithActorTypes("helloworld"),
-		actors.WithActorTypeHandler("helloworld", func(w http.ResponseWriter, req *http.Request) {
-			defer f.triggered.Append(path.Base(req.URL.Path))
-			if f.respErr.Load() {
-				w.WriteHeader(http.StatusInternalServerError)
-			}
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(f.actors),
-	}
-}
-
-func (f *failthird) Run(t *testing.T, ctx context.Context) {
-	f.actors.WaitUntilRunning(t, ctx)
-
-	_, err := f.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "helloworld",
-		ActorId:   "1234",
-		Name:      "test",
-		DueTime:   "1s",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, []string{"test", "test", "test"}, f.triggered.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	f.respErr.Store(false)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, []string{"test", "test", "test", "test"}, f.triggered.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	assert.ElementsMatch(t, []string{"test", "test", "test", "test"}, f.triggered.Slice())
-}
diff --git a/tests/integration/suite/actors/reminders/get.go b/tests/integration/suite/actors/reminders/get.go
deleted file mode 100644
index 390d20fde..000000000
--- a/tests/integration/suite/actors/reminders/get.go
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"strings"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(get))
-}
-
-type get struct {
-	actors *actors.Actors
-}
-
-func (g *get) Setup(t *testing.T) []framework.Option {
-	g.actors = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithFeatureSchedulerReminders(false),
-		actors.WithActorTypeHandler("foo", func(http.ResponseWriter, *http.Request) {}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(g.actors),
-	}
-}
-
-func (g *get) Run(t *testing.T, ctx context.Context) {
-	g.actors.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	url := g.actors.Daprd().ActorReminderURL("foo", "1234", "helloworld")
-	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
-	require.NoError(t, err)
-	resp, err := client.Do(req)
-	require.NoError(t, err)
-	// Not found returns 200.
-	assert.Equal(t, http.StatusOK, resp.StatusCode)
-	require.NoError(t, resp.Body.Close())
-
-	body := `{"data":"reminderdata","dueTime":"1s","period":"1s"}`
-	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(body))
-	require.NoError(t, err)
-	resp, err = client.Do(req)
-	require.NoError(t, err)
-	assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-	require.NoError(t, resp.Body.Close())
-
-	req, err = http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
-	require.NoError(t, err)
-	resp, err = client.Do(req)
-	require.NoError(t, err)
-	assert.Equal(t, http.StatusOK, resp.StatusCode)
-	b, err := io.ReadAll(resp.Body)
-	require.NoError(t, err)
-	require.NoError(t, resp.Body.Close())
-	assert.JSONEq(t, `{"period":"1s","data":"reminderdata","dueTime":"1s"}`, strings.TrimSpace(string(b)))
-}
diff --git a/tests/integration/suite/actors/reminders/hdata.go b/tests/integration/suite/actors/reminders/hdata.go
deleted file mode 100644
index 17c7f58d4..000000000
--- a/tests/integration/suite/actors/reminders/hdata.go
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"strings"
-	"sync"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(hdata))
-}
-
-type hdata struct {
-	daprd *daprd.Daprd
-	place *placement.Placement
-
-	lock sync.Mutex
-	data map[string]chan string
-}
-
-func (h *hdata) Setup(t *testing.T) []framework.Option {
-	h.data = make(map[string]chan string)
-
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
- name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false`), 0o600))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/{id}", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/{id}/method/remind/", func(w http.ResponseWriter, r *http.Request) {
-		b, err := io.ReadAll(r.Body)
-		assert.NoError(t, err)
-		h.lock.Lock()
-		ch := h.data[r.PathValue("id")]
-		h.lock.Unlock()
-		select {
-		case ch <- string(b):
-		case <-time.After(time.Second * 10):
-		}
-	})
-	handler.HandleFunc("/actors/myactortype/{id}/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	h.place = placement.New(t)
-	h.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(h.place.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(h.place, srv, h.daprd),
-	}
-}
-
-func (h *hdata) Run(t *testing.T, ctx context.Context) {
-	h.place.WaitUntilRunning(t, ctx)
-	h.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	aurl := h.daprd.ActorInvokeURL("myactortype", "myactorid", "foo")
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, aurl, nil)
-	require.NoError(t, err)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		resp, rErr := client.Do(req)
-		if assert.NoError(c, rErr) {
-			assert.NoError(c, resp.Body.Close())
-			assert.Equal(c, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-
-	gclient := h.daprd.GRPCClient(t, ctx)
-
-	tests := map[string]struct {
-		expHTTP string
-		expGRPC string
-	}{
-		``: {
-			`{"dueTime":"0s","period":""}`,
-			`{"dueTime":"0s","period":""}`,
-		},
-		`"foo"`: {
-			`{"data":"foo","dueTime":"0s","period":""}`,
-			`{"data":"ImZvbyI=","dueTime":"0s","period":""}`,
-		},
-		`{  "foo": [ 12, 4 ] }`: {
-			`{"data":{"foo":[12,4]},"dueTime":"0s","period":""}`,
-			`{"data":"eyAgImZvbyI6IFsgMTIsIDQgXSB9","dueTime":"0s","period":""}`,
-		},
-		`true`: {
-			`{"data":true,"dueTime":"0s","period":""}`,
-			`{"data":"dHJ1ZQ==","dueTime":"0s","period":""}`,
-		},
-		`null`: {
-			`{"data":null,"dueTime":"0s","period":""}`,
-			`{"data":"bnVsbA==","dueTime":"0s","period":""}`,
-		},
-		`[]`: {
-			`{"data":[],"dueTime":"0s","period":""}`,
-			`{"data":"W10=","dueTime":"0s","period":""}`,
-		},
-		`123`: {
-			`{"data":123,"dueTime":"0s","period":""}`,
-			`{"data":"MTIz","dueTime":"0s","period":""}`,
-		},
-	}
-
-	var i atomic.Int64
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			actorID := strconv.FormatInt(i.Add(1), 10)
-			h.lock.Lock()
-			ch := make(chan string, 1)
-			h.data[actorID] = ch
-			h.lock.Unlock()
-
-			body := `{"dueTime": "0s"`
-			if name != `` {
-				body += `,"data": ` + name
-			}
-			body += `}`
-			aurl := h.daprd.ActorReminderURL("myactortype", actorID, "remindermethod-http")
-			req, err := http.NewRequestWithContext(ctx, http.MethodPost, aurl, strings.NewReader(body))
-			require.NoError(t, err)
-
-			resp, err := client.Do(req)
-			require.NoError(t, err)
-			require.NoError(t, resp.Body.Close())
-			assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-			select {
-			case <-time.After(time.Second * 10):
-				require.FailNow(t, "timeout")
-			case got := <-ch:
-				assert.Equal(t, test.expHTTP, got, name)
-			}
-
-			_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-				ActorType: "myactortype",
-				ActorId:   actorID,
-				Name:      "remindermethod-grpc",
-				DueTime:   "0s",
-				Data:      []byte(name),
-			})
-			require.NoError(t, err)
-			select {
-			case <-time.After(time.Second * 10):
-				require.FailNow(t, "timeout")
-			case got := <-ch:
-				assert.Equal(t, test.expGRPC, got, name)
-			}
-		})
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/migration/migration.go b/tests/integration/suite/actors/reminders/migration/migration.go
deleted file mode 100644
index d1497ea6b..000000000
--- a/tests/integration/suite/actors/reminders/migration/migration.go
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package migration
-
-import (
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/migration/scheduler"
-)
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/basic.go b/tests/integration/suite/actors/reminders/migration/scheduler/basic.go
deleted file mode 100644
index a5fff6ab8..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/basic.go
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(basic))
-}
-
-type basic struct {
-	db        *sqlite.SQLite
-	app       *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-}
-
-func (b *basic) Setup(t *testing.T) []framework.Option {
-	b.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	b.app = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-	)
-	b.scheduler = scheduler.New(t)
-	b.place = placement.New(t)
-
-	return []framework.Option{
-		framework.WithProcesses(b.db, b.scheduler, b.place, b.app),
-	}
-}
-
-func (b *basic) Run(t *testing.T, ctx context.Context) {
-	opts := []daprd.Option{
-		daprd.WithResourceFiles(b.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(b.place.Address()),
-		daprd.WithSchedulerAddresses(b.scheduler.Address()),
-		daprd.WithAppPort(b.app.Port()),
-	}
-
-	daprd1 := daprd.New(t, append(opts,
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`))...)
-	daprd2 := daprd.New(t, opts...)
-
-	daprd1.Run(t, ctx)
-	daprd1.WaitUntilRunning(t, ctx)
-
-	assert.Empty(t, b.scheduler.EtcdJobs(t, ctx))
-	assert.Empty(t, b.db.ActorReminders(t, ctx, "myactortype").Reminders)
-
-	client := daprd1.GRPCClient(t, ctx)
-	_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "10000s",
-		Period:    "10000s",
-		Data:      []byte("mydata"),
-		Ttl:       "10000s",
-	})
-	require.NoError(t, err)
-	assert.Len(t, b.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-	assert.Empty(t, b.scheduler.EtcdJobs(t, ctx))
-	daprd1.Cleanup(t)
-
-	daprd2.Run(t, ctx)
-	daprd2.WaitUntilRunning(t, ctx)
-	assert.Len(t, b.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Len(c, b.scheduler.EtcdJobs(t, ctx), 1)
-	}, time.Second*5, time.Millisecond*10)
-	daprd2.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/data.go b/tests/integration/suite/actors/reminders/migration/scheduler/data.go
deleted file mode 100644
index 1d2fccece..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/data.go
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(data))
-}
-
-type data struct {
-	db        *sqlite.SQLite
-	app       *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	called atomic.Bool
-	got    atomic.Value
-}
-
-func (d *data) Setup(t *testing.T) []framework.Option {
-	d.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	d.app = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(_ http.ResponseWriter, r *http.Request) {
-		}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/remind/myreminder", func(_ http.ResponseWriter, r *http.Request) {
-			b, err := io.ReadAll(r.Body)
-			assert.NoError(t, err)
-			d.got.Store(b)
-			assert.True(t, d.called.CompareAndSwap(false, true))
-		}),
-	)
-	d.scheduler = scheduler.New(t)
-	d.place = placement.New(t)
-
-	return []framework.Option{
-		framework.WithProcesses(d.db, d.scheduler, d.place, d.app),
-	}
-}
-
-func (d *data) Run(t *testing.T, ctx context.Context) {
-	opts := []daprd.Option{
-		daprd.WithResourceFiles(d.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-		daprd.WithAppPort(d.app.Port()),
-	}
-
-	daprd1 := daprd.New(t, append(opts,
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`))...)
-	daprd2 := daprd.New(t, opts...)
-
-	t.Cleanup(func() { daprd1.Cleanup(t) })
-	daprd1.Run(t, ctx)
-	daprd1.WaitUntilRunning(t, ctx)
-
-	_, err := daprd1.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "3s",
-		Data:      []byte("mydata"),
-	})
-	require.NoError(t, err)
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-	assert.Empty(t, d.scheduler.EtcdJobs(t, ctx))
-	daprd1.Cleanup(t)
-
-	assert.False(t, d.called.Load())
-
-	daprd2.Run(t, ctx)
-	daprd2.WaitUntilRunning(t, ctx)
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.True(c, d.called.Load())
-	}, time.Second*10, time.Millisecond*10)
-
-	got, ok := d.got.Load().([]byte)
-	assert.True(t, ok)
-	assert.JSONEq(t, `{"data":"bXlkYXRh","dueTime":"","period":""}`, string(got))
-
-	daprd2.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/distributed.go b/tests/integration/suite/actors/reminders/migration/scheduler/distributed.go
deleted file mode 100644
index ed9ec5eb8..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/distributed.go
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"strconv"
-	"sync"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(distributed))
-}
-
-type distributed struct {
-	db        *sqlite.SQLite
-	app1      *app.App
-	app2      *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-}
-
-func (d *distributed) Setup(t *testing.T) []framework.Option {
-	d.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	d.app1 = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype","myactortype2"]}`),
-		app.WithHandlerFunc("/actors", func(http.ResponseWriter, *http.Request) {}),
-	)
-	d.app2 = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors", func(http.ResponseWriter, *http.Request) {}),
-	)
-	d.scheduler = scheduler.New(t)
-	d.place = placement.New(t)
-
-	return []framework.Option{
-		framework.WithProcesses(d.db, d.scheduler, d.place, d.app1, d.app2),
-	}
-}
-
-func (d *distributed) Run(t *testing.T, ctx context.Context) {
-	schedOffConfig := `apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`
-
-	optsApp1 := []daprd.Option{
-		daprd.WithResourceFiles(d.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-		daprd.WithAppPort(d.app1.Port()),
-		daprd.WithConfigManifests(t, schedOffConfig),
-	}
-	optsApp2 := []daprd.Option{
-		daprd.WithResourceFiles(d.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-		daprd.WithAppPort(d.app2.Port()),
-	}
-	optsApp1WithScheduler := []daprd.Option{
-		daprd.WithResourceFiles(d.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-		daprd.WithAppPort(d.app1.Port()),
-	}
-
-	daprd1 := daprd.New(t, optsApp1...)
-	daprd2 := daprd.New(t, optsApp2...)
-	daprd3 := daprd.New(t, optsApp2...)
-	daprd4 := daprd.New(t, optsApp2...)
-	daprd5 := daprd.New(t, optsApp2...)
-	daprd6 := daprd.New(t, optsApp1WithScheduler...)
-
-	daprd1.Run(t, ctx)
-	t.Cleanup(func() { daprd1.Cleanup(t) })
-	daprd1.WaitUntilRunning(t, ctx)
-	client := daprd1.GRPCClient(t, ctx)
-
-	var wg sync.WaitGroup
-	wg.Add(200)
-	for i := range 100 {
-		go func(i int) {
-			defer wg.Done()
-			_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-				ActorType: "myactortype",
-				ActorId:   strconv.Itoa(i),
-				Name:      strconv.Itoa(i),
-				DueTime:   "10000s",
-			})
-			assert.NoError(t, err)
-		}(i)
-		go func(i int) {
-			defer wg.Done()
-			_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-				ActorType: "myactortype2",
-				ActorId:   strconv.Itoa(i),
-				Name:      strconv.Itoa(i),
-				DueTime:   "10000s",
-			})
-			assert.NoError(t, err)
-		}(i)
-	}
-	wg.Wait()
-
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype").Reminders, 100)
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype2").Reminders, 100)
-	assert.Empty(t, d.scheduler.EtcdJobs(t, ctx))
-
-	daprd1.Cleanup(t)
-
-	daprd2.Run(t, ctx)
-	t.Cleanup(func() { daprd2.Cleanup(t) })
-	daprd3.Run(t, ctx)
-	t.Cleanup(func() { daprd3.Cleanup(t) })
-	daprd4.Run(t, ctx)
-	t.Cleanup(func() { daprd4.Cleanup(t) })
-	daprd5.Run(t, ctx)
-	t.Cleanup(func() { daprd5.Cleanup(t) })
-
-	daprd2.WaitUntilRunning(t, ctx)
-	daprd3.WaitUntilRunning(t, ctx)
-	daprd4.WaitUntilRunning(t, ctx)
-	daprd5.WaitUntilRunning(t, ctx)
-
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype").Reminders, 100)
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype2").Reminders, 100)
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Len(c, d.scheduler.EtcdJobs(t, ctx), 100)
-	}, time.Second*5, time.Millisecond*10)
-
-	daprd6.Run(t, ctx)
-	t.Cleanup(func() { daprd6.Cleanup(t) })
-	daprd6.WaitUntilRunning(t, ctx)
-
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype").Reminders, 100)
-	assert.Len(t, d.db.ActorReminders(t, ctx, "myactortype2").Reminders, 100)
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Len(c, d.scheduler.EtcdJobs(t, ctx), 200)
-	}, time.Second*5, time.Millisecond*10)
-
-	daprd2.Cleanup(t)
-	daprd3.Cleanup(t)
-	daprd4.Cleanup(t)
-	daprd5.Cleanup(t)
-	daprd6.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/noop.go b/tests/integration/suite/actors/reminders/migration/scheduler/noop.go
deleted file mode 100644
index d330d20d9..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/noop.go
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	clientv3 "go.etcd.io/etcd/client/v3"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(noop))
-}
-
-type noop struct {
-	db        *sqlite.SQLite
-	app       *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-}
-
-func (n *noop) Setup(t *testing.T) []framework.Option {
-	n.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	n.app = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-	)
-	n.scheduler = scheduler.New(t, scheduler.WithLogLevel("debug"))
-	n.place = placement.New(t)
-
-	return []framework.Option{
-		framework.WithProcesses(n.db, n.scheduler, n.place, n.app),
-	}
-}
-
-func (n *noop) Run(t *testing.T, ctx context.Context) {
-	opts := []daprd.Option{
-		daprd.WithResourceFiles(n.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(n.place.Address()),
-		daprd.WithSchedulerAddresses(n.scheduler.Address()),
-		daprd.WithAppPort(n.app.Port()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`),
-	}
-
-	daprd1 := daprd.New(t, opts...)
-	daprd2 := daprd.New(t, opts...)
-
-	daprd1.Run(t, ctx)
-	daprd1.WaitUntilRunning(t, ctx)
-	client := daprd1.GRPCClient(t, ctx)
-	_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "10000s",
-		Period:    "10000s",
-		Data:      []byte("mydata"),
-		Ttl:       "10000s",
-	})
-	require.NoError(t, err)
-	resp, err := n.scheduler.ETCDClient(t, ctx).KV.Get(ctx, "dapr/jobs", clientv3.WithPrefix())
-	require.NoError(t, err)
-	assert.Empty(t, resp.Kvs)
-	daprd1.Cleanup(t)
-
-	daprd2.Run(t, ctx)
-	daprd2.WaitUntilRunning(t, ctx)
-	resp, err = n.scheduler.ETCDClient(t, ctx).KV.Get(ctx, "dapr/jobs", clientv3.WithPrefix())
-	require.NoError(t, err)
-	assert.Empty(t, resp.Kvs)
-	daprd2.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go b/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go
deleted file mode 100644
index 0fe0f9ef6..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	clientv3 "go.etcd.io/etcd/client/v3"
-	"google.golang.org/protobuf/types/known/anypb"
-	"google.golang.org/protobuf/types/known/durationpb"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-
-	corev1 "github.com/dapr/dapr/pkg/proto/common/v1"
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	schedulerv1 "github.com/dapr/dapr/pkg/proto/scheduler/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/ptr"
-)
-
-func init() {
-	suite.Register(new(overwrite))
-}
-
-type overwrite struct {
-	db        *sqlite.SQLite
-	app       *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-}
-
-func (o *overwrite) Setup(t *testing.T) []framework.Option {
-	o.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	o.app = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-	)
-	o.scheduler = scheduler.New(t, scheduler.WithLogLevel("debug"))
-	o.place = placement.New(t)
-
-	return []framework.Option{
-		framework.WithProcesses(o.db, o.scheduler, o.place, o.app),
-	}
-}
-
-func (o *overwrite) Run(t *testing.T, ctx context.Context) {
-	opts := []daprd.Option{
-		daprd.WithResourceFiles(o.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(o.place.Address()),
-		daprd.WithSchedulerAddresses(o.scheduler.Address()),
-		daprd.WithAppPort(o.app.Port()),
-	}
-
-	optsWithoutScheduler := []daprd.Option{
-		daprd.WithResourceFiles(o.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(o.place.Address()),
-		daprd.WithSchedulerAddresses(o.scheduler.Address()),
-		daprd.WithAppPort(o.app.Port()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`),
-	}
-
-	daprd1 := daprd.New(t, opts...)
-	daprd2 := daprd.New(t, optsWithoutScheduler...)
-	daprd3 := daprd.New(t, opts...)
-
-	daprd1.Run(t, ctx)
-	daprd1.WaitUntilRunning(t, ctx)
-	client := daprd1.GRPCClient(t, ctx)
-	_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "10000s",
-		Period:    "R100/PT10000S",
-		Data:      []byte("mydata1"),
-		Ttl:       "10000s",
-	})
-	require.NoError(t, err)
-	sclient := o.scheduler.Client(t, ctx)
-	resp, err := sclient.ListJobs(ctx, &schedulerv1.ListJobsRequest{
-		Metadata: &schedulerv1.JobMetadata{
-			AppId:     daprd1.AppID(),
-			Namespace: daprd1.Namespace(),
-			Target: &schedulerv1.JobTargetMetadata{
-				Type: &schedulerv1.JobTargetMetadata_Actor{
-					Actor: &schedulerv1.TargetActorReminder{
-						Id:   "myactorid",
-						Type: "myactortype",
-					},
-				},
-			},
-		},
-	})
-	require.NoError(t, err)
-
-	require.Len(t, resp.GetJobs(), 1)
-	njob := resp.GetJobs()[0]
-	assert.Equal(t, "myreminder", njob.GetName())
-	expAny, err := anypb.New(wrapperspb.Bytes([]byte(`"bXlkYXRhMQ=="`)))
-	require.NoError(t, err)
-	assert.Equal(t, &schedulerv1.Job{
-		Schedule: ptr.Of("@every 2h46m40s"),
-		DueTime:  ptr.Of("10000s"),
-		Ttl:      ptr.Of("10000s"),
-		Data:     expAny,
-		Repeats:  ptr.Of(uint32(100)),
-		FailurePolicy: &corev1.JobFailurePolicy{
-			Policy: &corev1.JobFailurePolicy_Constant{
-				Constant: &corev1.JobFailurePolicyConstant{
-					Interval:   durationpb.New(time.Second * 1),
-					MaxRetries: ptr.Of(uint32(3)),
-				},
-			},
-		},
-	}, njob.GetJob())
-	daprd1.Cleanup(t)
-
-	daprd2.Run(t, ctx)
-	daprd2.WaitUntilRunning(t, ctx)
-	client = daprd2.GRPCClient(t, ctx)
-	_, err = client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "20000s",
-		Period:    "R200/PT20000S",
-		Data:      []byte("mydata2"),
-		Ttl:       "20000s",
-	})
-	require.NoError(t, err)
-	eresp, err := o.scheduler.ETCDClient(t, ctx).KV.Get(ctx, "dapr/jobs", clientv3.WithPrefix())
-	require.NoError(t, err)
-	assert.Len(t, eresp.Kvs, 1)
-
-	resp, err = sclient.ListJobs(ctx, &schedulerv1.ListJobsRequest{
-		Metadata: &schedulerv1.JobMetadata{
-			AppId:     daprd2.AppID(),
-			Namespace: daprd2.Namespace(),
-			Target: &schedulerv1.JobTargetMetadata{
-				Type: &schedulerv1.JobTargetMetadata_Actor{
-					Actor: &schedulerv1.TargetActorReminder{
-						Id:   "myactorid",
-						Type: "myactortype",
-					},
-				},
-			},
-		},
-	})
-	require.NoError(t, err)
-	require.Len(t, resp.GetJobs(), 1)
-	njob = resp.GetJobs()[0]
-	assert.Equal(t, "myreminder", njob.GetName())
-	expAny, err = anypb.New(wrapperspb.Bytes([]byte(`"bXlkYXRhMQ=="`)))
-	require.NoError(t, err)
-	assert.Equal(t, &schedulerv1.Job{
-		Schedule: ptr.Of("@every 2h46m40s"),
-		DueTime:  ptr.Of("10000s"),
-		Ttl:      ptr.Of("10000s"),
-		Data:     expAny,
-		Repeats:  ptr.Of(uint32(100)),
-		FailurePolicy: &corev1.JobFailurePolicy{
-			Policy: &corev1.JobFailurePolicy_Constant{
-				Constant: &corev1.JobFailurePolicyConstant{
-					Interval:   durationpb.New(time.Second * 1),
-					MaxRetries: ptr.Of(uint32(3)),
-				},
-			},
-		},
-	}, njob.GetJob())
-	daprd2.Cleanup(t)
-
-	daprd3.Run(t, ctx)
-	daprd3.WaitUntilRunning(t, ctx)
-	resp, err = sclient.ListJobs(ctx, &schedulerv1.ListJobsRequest{
-		Metadata: &schedulerv1.JobMetadata{
-			AppId:     daprd2.AppID(),
-			Namespace: daprd2.Namespace(),
-			Target: &schedulerv1.JobTargetMetadata{
-				Type: &schedulerv1.JobTargetMetadata_Actor{
-					Actor: &schedulerv1.TargetActorReminder{
-						Id:   "myactorid",
-						Type: "myactortype",
-					},
-				},
-			},
-		},
-	})
-	require.NoError(t, err)
-	require.Len(t, resp.GetJobs(), 1)
-	njob = resp.GetJobs()[0]
-	assert.Equal(t, "myreminder", njob.GetName())
-	expAny, err = anypb.New(wrapperspb.Bytes([]byte(`"bXlkYXRhMg=="`)))
-	require.NoError(t, err)
-	assert.Equal(t, "@every 5h33m20s", njob.GetJob().GetSchedule())
-	assert.Equal(t, "20000s", njob.GetJob().GetDueTime())
-	expTTL := time.Now().Add(20000 * time.Second)
-	gotTTL, err := time.Parse(time.RFC3339, njob.GetJob().GetTtl())
-	require.NoError(t, err)
-	assert.InDelta(t, expTTL.UnixMilli(), gotTTL.UnixMilli(), float64(time.Second*10))
-	assert.Equal(t, expAny, njob.GetJob().GetData())
-	assert.Equal(t, uint32(200), njob.GetJob().GetRepeats())
-	daprd3.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/rebalance.go b/tests/integration/suite/actors/reminders/migration/scheduler/rebalance.go
deleted file mode 100644
index 67e8c251a..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/rebalance.go
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"strconv"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(rebalance))
-}
-
-type rebalance struct {
-	actor1 *actors.Actors
-	actor2 *actors.Actors
-}
-
-func (r *rebalance) Setup(t *testing.T) []framework.Option {
-	r.actor1 = actors.New(t,
-		actors.WithActorTypes("myactortype"),
-		actors.WithFeatureSchedulerReminders(false),
-	)
-	r.actor2 = actors.New(t,
-		actors.WithDB(r.actor1.DB()),
-		actors.WithScheduler(r.actor1.Scheduler()),
-		actors.WithActorTypes("myactortype"),
-		actors.WithPlacement(r.actor1.Placement()),
-		actors.WithFeatureSchedulerReminders(true),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(r.actor1, r.actor2),
-	}
-}
-
-func (r *rebalance) Run(t *testing.T, ctx context.Context) {
-	r.actor1.WaitUntilRunning(t, ctx)
-	r.actor2.WaitUntilRunning(t, ctx)
-
-	assert.Empty(t, r.actor1.DB().ActorReminders(t, ctx, "myactortype").Reminders)
-	assert.Empty(t, r.actor2.DB().ActorReminders(t, ctx, "myactortype").Reminders)
-	assert.Empty(t, r.actor1.Scheduler().EtcdJobs(t, ctx))
-	assert.Empty(t, r.actor2.Scheduler().EtcdJobs(t, ctx))
-
-	for i := range 200 {
-		_, err := r.actor1.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "initial-" + strconv.Itoa(i),
-			Name:      "foo",
-			DueTime:   "1000s",
-		})
-		require.NoError(t, err)
-	}
-
-	assert.Len(t, r.actor1.DB().ActorReminders(t, ctx, "myactortype").Reminders, 200)
-	assert.Len(t, r.actor2.DB().ActorReminders(t, ctx, "myactortype").Reminders, 200)
-
-	assert.Empty(t, r.actor1.Scheduler().EtcdJobs(t, ctx))
-
-	t.Run("new daprd", func(t *testing.T) {
-		daprd := actors.New(t,
-			actors.WithDB(r.actor1.DB()),
-			actors.WithActorTypes("myactortype"),
-			actors.WithFeatureSchedulerReminders(true),
-			actors.WithPlacement(r.actor1.Placement()),
-			actors.WithScheduler(r.actor1.Scheduler()),
-		)
-		t.Cleanup(func() { daprd.Cleanup(t) })
-		daprd.Run(t, ctx)
-		daprd.WaitUntilRunning(t, ctx)
-
-		assert.Len(t, r.actor1.DB().ActorReminders(t, ctx, "myactortype").Reminders, 200)
-		assert.Len(t, r.actor2.DB().ActorReminders(t, ctx, "myactortype").Reminders, 200)
-		assert.Len(t, daprd.DB().ActorReminders(t, ctx, "myactortype").Reminders, 200)
-
-		assert.EventuallyWithT(t, func(c *assert.CollectT) {
-			assert.NotEmpty(c, r.actor1.Scheduler().EtcdJobs(t, ctx))
-			assert.NotEmpty(c, daprd.Scheduler().EtcdJobs(t, ctx))
-		}, time.Second*5, time.Millisecond*10)
-		daprd.Cleanup(t)
-	})
-}
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/skip.go b/tests/integration/suite/actors/reminders/migration/scheduler/skip.go
deleted file mode 100644
index e454b8dc6..000000000
--- a/tests/integration/suite/actors/reminders/migration/scheduler/skip.go
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/logline"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(skip))
-}
-
-type skip struct {
-	db        *sqlite.SQLite
-	app       *app.App
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	skiplog *logline.LogLine
-}
-
-func (s *skip) Setup(t *testing.T) []framework.Option {
-	s.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-	s.app = app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-	)
-	s.scheduler = scheduler.New(t)
-	s.place = placement.New(t)
-
-	s.skiplog = logline.New(t, logline.WithStdoutLineContains(
-		"Skipping migration of reminders to scheduler as requested.",
-	))
-
-	return []framework.Option{
-		framework.WithProcesses(s.skiplog, s.db, s.scheduler, s.place, s.app),
-	}
-}
-
-func (s *skip) Run(t *testing.T, ctx context.Context) {
-	opts := []daprd.Option{
-		daprd.WithResourceFiles(s.db.GetComponent(t)),
-		daprd.WithPlacementAddresses(s.place.Address()),
-		daprd.WithSchedulerAddresses(s.scheduler.Address()),
-		daprd.WithAppPort(s.app.Port()),
-	}
-
-	daprd1 := daprd.New(t, append(opts,
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`))...)
-
-	daprd2 := daprd.New(t,
-		append(opts,
-			daprd.WithLogLineStdout(s.skiplog),
-			daprd.WithSkipStateStoreReminderMigration(t),
-		)...,
-	)
-
-	daprd1.Run(t, ctx)
-	daprd1.WaitUntilRunning(t, ctx)
-
-	assert.Empty(t, s.scheduler.EtcdJobs(t, ctx))
-	assert.Empty(t, s.db.ActorReminders(t, ctx, "myactortype").Reminders)
-
-	client := daprd1.GRPCClient(t, ctx)
-	_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "myreminder",
-		DueTime:   "10000s",
-		Period:    "10000s",
-		Data:      []byte("mydata"),
-		Ttl:       "10000s",
-	})
-	require.NoError(t, err)
-	assert.Len(t, s.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-	assert.Empty(t, s.scheduler.EtcdJobs(t, ctx))
-	daprd1.Cleanup(t)
-
-	daprd2.Run(t, ctx)
-	daprd2.WaitUntilRunning(t, ctx)
-	assert.Len(t, s.db.ActorReminders(t, ctx, "myactortype").Reminders, 1)
-	time.Sleep(time.Second * 3)
-	assert.Empty(t, s.scheduler.EtcdJobs(t, ctx), 0)
-	daprd2.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/overwrite.go b/tests/integration/suite/actors/reminders/overwrite.go
deleted file mode 100644
index a55533765..000000000
--- a/tests/integration/suite/actors/reminders/overwrite.go
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-Copyright 2025 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"testing"
-
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(overwrite))
-}
-
-type overwrite struct {
-	actors *actors.Actors
-}
-
-func (o *overwrite) Setup(t *testing.T) []framework.Option {
-	o.actors = actors.New(t,
-		actors.WithActorTypes("abc"),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(o.actors),
-	}
-}
-
-func (o *overwrite) Run(t *testing.T, ctx context.Context) {
-	o.actors.WaitUntilRunning(t, ctx)
-
-	client := o.actors.GRPCClient(t, ctx)
-	_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "abc",
-		ActorId:   "123",
-		Name:      "reminder1",
-		DueTime:   "24h",
-	})
-	require.NoError(t, err)
-
-	_, err = client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "abc",
-		ActorId:   "123",
-		Name:      "reminder1",
-		DueTime:   "48h",
-	})
-	require.NoError(t, err)
-}
diff --git a/tests/integration/suite/actors/reminders/period.go b/tests/integration/suite/actors/reminders/period.go
deleted file mode 100644
index 706e7f766..000000000
--- a/tests/integration/suite/actors/reminders/period.go
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"net/http"
-	"strings"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(period))
-}
-
-type period struct {
-	actors *actors.Actors
-	count  atomic.Int64
-}
-
-func (p *period) Setup(t *testing.T) []framework.Option {
-	p.count.Store(0)
-	p.actors = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(w http.ResponseWriter, r *http.Request) {
-			if r.Method == http.MethodDelete {
-				return
-			}
-			p.count.Add(1)
-		}),
-		actors.WithFeatureSchedulerReminders(false),
-	)
-	actors2 := actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(w http.ResponseWriter, r *http.Request) {
-			if r.Method == http.MethodDelete {
-				return
-			}
-			p.count.Add(1)
-		}),
-		actors.WithFeatureSchedulerReminders(false),
-		actors.WithPeerActor(p.actors),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(actors2, p.actors),
-	}
-}
-
-func (p *period) Run(t *testing.T, ctx context.Context) {
-	p.actors.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	url := p.actors.Daprd().ActorReminderURL("foo", "1234", "helloworld")
-	body := `{"data":"reminderdata","dueTime":"1s","period":"R5/PT1S"}`
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(body))
-	require.NoError(t, err)
-	resp, err := client.Do(req)
-	require.NoError(t, err)
-	assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-	require.NoError(t, resp.Body.Close())
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Equal(c, int64(5), p.count.Load())
-	}, 20*time.Second, 1*time.Second)
-
-	time.Sleep(time.Second * 3)
-	assert.Equal(t, int64(5), p.count.Load())
-}
diff --git a/tests/integration/suite/actors/reminders/rebalancing.go b/tests/integration/suite/actors/reminders/rebalancing.go
deleted file mode 100644
index 98200a2b6..000000000
--- a/tests/integration/suite/actors/reminders/rebalancing.go
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"errors"
-	"fmt"
-	"io"
-	"log"
-	"net/http"
-	"strconv"
-	"strings"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	chi "github.com/go-chi/chi/v5"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	grpcinsecure "google.golang.org/grpc/credentials/insecure"
-
-	placementv1pb "github.com/dapr/dapr/pkg/proto/placement/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(rebalancing))
-}
-
-// Number of iterations for the test
-const iterations = 30
-
-// rebalancing tests that during rebalancing, reminders do not cause actors to be activated on 2 separate hosts.
-type rebalancing struct {
-	daprd              [2]*daprd.Daprd
-	srv                [2]*prochttp.HTTP
-	handler            [2]*httpServer
-	db                 *sqlite.SQLite
-	place              *placement.Placement
-	activeActors       []atomic.Bool
-	doubleActivationCh chan string
-	scheduler          *scheduler.Scheduler
-}
-
-func (i *rebalancing) Setup(t *testing.T) []framework.Option {
-	i.activeActors = make([]atomic.Bool, iterations)
-	i.doubleActivationCh = make(chan string)
-
-	// Create the SQLite database
-	i.db = sqlite.New(t,
-		sqlite.WithActorStateStore(true),
-		sqlite.WithMetadata("busyTimeout", "10s"),
-		sqlite.WithMetadata("disableWAL", "true"),
-	)
-
-	// Init placement
-	i.place = placement.New(t)
-
-	i.scheduler = scheduler.New(t)
-
-	// Init two instances of daprd, each with its own server
-	for j := range 2 {
-		i.handler[j] = &httpServer{
-			activeActors:       i.activeActors,
-			doubleActivationCh: i.doubleActivationCh,
-		}
-		i.srv[j] = prochttp.New(t, prochttp.WithHandler(i.handler[j].NewHandler(j)))
-		i.daprd[j] = daprd.New(t,
-			daprd.WithResourceFiles(i.db.GetComponent(t)),
-			daprd.WithPlacementAddresses(i.place.Address()),
-			daprd.WithSchedulerAddresses(i.scheduler.Address()),
-			daprd.WithAppPort(i.srv[j].Port()),
-			// Daprd is super noisy in debug mode when connecting to placement.
-			daprd.WithLogLevel("info"),
-			daprd.WithAppHealthCheck(true),
-		)
-	}
-
-	return []framework.Option{
-		framework.WithProcesses(i.db, i.place, i.scheduler, i.srv[0], i.srv[1], i.daprd[0], i.daprd[1]),
-	}
-}
-
-func (i *rebalancing) Run(t *testing.T, ctx context.Context) {
-	i.scheduler.WaitUntilRunning(t, ctx)
-	i.place.WaitUntilRunning(t, ctx)
-
-	// Wait for daprd to be ready
-	for j := range 2 {
-		i.daprd[j].WaitUntilRunning(t, ctx)
-	}
-	// Wait for actors to be ready
-	for j := range 2 {
-		err := i.handler[j].WaitForActorsReady(ctx)
-		require.NoErrorf(t, err, "Actor instance %d not ready", j)
-	}
-
-	// Establish a connection to the placement service
-	stream := i.getPlacementStream(t, ctx)
-
-	client := client.HTTP(t)
-
-	// Try to invoke an actor to ensure the actor subsystem is ready
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		req, err := http.NewRequest(http.MethodPost, fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/pinger/method/ping", i.daprd[0].HTTPPort()), nil)
-		if assert.NoError(c, err) {
-			resp, rErr := client.Do(req)
-			if assert.NoError(c, rErr) {
-				assert.NoError(c, resp.Body.Close())
-				assert.Equal(c, http.StatusOK, resp.StatusCode)
-			}
-		}
-	}, 15*time.Second, 10*time.Millisecond, "actors not ready")
-
-	// Do a bunch of things in parallel
-	errCh := make(chan error)
-
-	// To start, monitor for double activations
-	go func() {
-		errs := make([]error, 0)
-		for doubleAct := range i.doubleActivationCh {
-			// An empty message is a signal to stop
-			if doubleAct == "" {
-				break
-			}
-			errs = append(errs, fmt.Errorf("double activation of actor %s", doubleAct))
-		}
-		if len(errs) > 0 {
-			errCh <- errors.Join(errs...)
-		} else {
-			errCh <- nil
-		}
-	}()
-
-	// Schedule reminders to be executed in 0s
-	for j := range iterations {
-		go func(j int) {
-			rctx, cancel := context.WithTimeout(ctx, 5*time.Second)
-			defer cancel()
-			body := `{"dueTime": "0s"}`
-			daprdURL := fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/myactorid-%d/reminders/reminder%d", i.daprd[0].HTTPPort(), j, j)
-			req, rErr := http.NewRequestWithContext(rctx, http.MethodPost, daprdURL, strings.NewReader(body))
-			req.Header.Set("Content-Type", "application/json")
-			if rErr != nil {
-				errCh <- fmt.Errorf("failed scheduling reminder %d: %w", j, rErr)
-				return
-			}
-			resp, rErr := client.Do(req)
-			if rErr != nil {
-				errCh <- fmt.Errorf("failed scheduling reminder %d: %w", j, rErr)
-				return
-			}
-			defer resp.Body.Close()
-			if resp.StatusCode != http.StatusNoContent {
-				rb, _ := io.ReadAll(resp.Body)
-				errCh <- fmt.Errorf("failed scheduling reminder %d: status code is %d. Body: %s", j, resp.StatusCode, string(rb))
-				return
-			}
-			errCh <- nil
-		}(j)
-	}
-
-	// In parallel, add another node to the placement which will trigger a rebalancing
-	go func() {
-		rErr := i.reportStatusToPlacement(ctx, stream, []string{"myactortype"})
-		if rErr != nil {
-			errCh <- fmt.Errorf("failed to trigger rebalancing: %w", rErr)
-		} else {
-			errCh <- nil
-		}
-	}()
-
-	// Also invoke the same actors using actor invocation
-	for j := range iterations {
-		go func(j int) {
-			rctx, cancel := context.WithTimeout(ctx, 20*time.Second)
-			defer cancel()
-			daprdURL := fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/myactorid-%d/method/foo", i.daprd[0].HTTPPort(), j)
-			req, rErr := http.NewRequestWithContext(rctx, http.MethodPost, daprdURL, nil)
-			if rErr != nil {
-				errCh <- fmt.Errorf("failed invoking actor %d: %w", j, rErr)
-				return
-			}
-			assert.Eventually(t,
-				func() bool {
-					resp, respErr := client.Do(req)
-					if respErr != nil {
-						rErr = fmt.Errorf("failed invoking actor %d: %w", j, rErr)
-						return false
-					}
-					defer resp.Body.Close()
-					// We don't check the status code here as it could be 500 if we tried invoking the fake app
-					if resp.StatusCode != http.StatusOK {
-						log.Printf("MYLOG Invoking actor %d on non-existent host", j)
-					}
-
-					rErr = nil
-					return true
-				}, 20*time.Second, 1*time.Second)
-			errCh <- rErr
-		}(j)
-	}
-
-	// After 2s, stop doubleActivationCh by sending an empty message
-	go func() {
-		<-time.After(2 * time.Second)
-		i.doubleActivationCh <- ""
-	}()
-
-	// Wait for all operations to complete
-	for range (iterations * 2) + 2 {
-		require.NoError(t, <-errCh)
-	}
-}
-
-type httpServer struct {
-	num                int
-	actorsReady        atomic.Bool
-	actorsReadyCh      chan struct{}
-	activeActors       []atomic.Bool
-	doubleActivationCh chan string
-}
-
-func (h *httpServer) NewHandler(num int) http.Handler {
-	h.actorsReadyCh = make(chan struct{})
-	h.num = num
-
-	r := chi.NewRouter()
-	r.Get("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	r.Get("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		if h.actorsReady.CompareAndSwap(false, true) {
-			close(h.actorsReadyCh)
-		}
-		w.WriteHeader(http.StatusOK)
-	})
-	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`OK`))
-	})
-	r.Put("/actors/{actorType}/{actorId}/method/{methodName}", func(w http.ResponseWriter, r *http.Request) {
-		// Invoke method
-		actorType := chi.URLParam(r, "actorType")
-		actorID := chi.URLParam(r, "actorId")
-		methodName := chi.URLParam(r, "methodName")
-
-		// Check if this is just a ping and return quickly
-		if methodName == "ping" {
-			w.WriteHeader(http.StatusOK)
-			return
-		}
-
-		parts := strings.Split(actorID, "-")
-		if len(parts) != 2 {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-		actorIDNum, err := strconv.Atoi(parts[1])
-		if err != nil {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-		if actorIDNum > len(h.activeActors) {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-
-		if !h.activeActors[actorIDNum].CompareAndSwap(false, true) {
-			log.Printf("BUG!!! ACTOR %s/%s IS ALREADY ACTIVE ON ANOTHER HOST", actorType, actorID)
-			h.doubleActivationCh <- fmt.Sprintf("%s/%s", actorType, actorID)
-		}
-		log.Printf("MYLOG [%d] Invoked actor %s/%s: method %s", h.num, actorType, actorID, methodName)
-
-		// Simulate the actor doing some work
-		time.Sleep(2 * time.Second)
-		h.activeActors[actorIDNum].Store(false)
-
-		w.WriteHeader(http.StatusOK)
-	})
-	r.Put("/actors/{actorType}/{actorId}/method/remind/{reminderName}", func(w http.ResponseWriter, r *http.Request) {
-		// Invoke reminder
-		actorType := chi.URLParam(r, "actorType")
-		actorID := chi.URLParam(r, "actorId")
-		reminderName := chi.URLParam(r, "reminderName")
-
-		parts := strings.Split(actorID, "-")
-		if len(parts) != 2 {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-		actorIDNum, err := strconv.Atoi(parts[1])
-		if err != nil {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-		if actorIDNum > len(h.activeActors) {
-			w.WriteHeader(http.StatusInternalServerError)
-			return
-		}
-
-		if !h.activeActors[actorIDNum].CompareAndSwap(false, true) {
-			log.Printf("BUG!!! ACTOR %s/%s IS ALREADY ACTIVE ON ANOTHER HOST", actorType, actorID)
-			h.doubleActivationCh <- fmt.Sprintf("%s/%s", actorType, actorID)
-		}
-		log.Printf("MYLOG [%d] Invoked actor %s/%s: reminder %s", h.num, actorType, actorID, reminderName)
-
-		// Simulate the actor doing some work
-		time.Sleep(2 * time.Second)
-		h.activeActors[actorIDNum].Store(false)
-
-		w.WriteHeader(http.StatusOK)
-	})
-	r.Delete("/actors/{actorType}/{actorId}", func(w http.ResponseWriter, r *http.Request) {
-		// Deactivate actor
-		actorType := chi.URLParam(r, "actorType")
-		actorID := chi.URLParam(r, "actorId")
-		log.Printf("MYLOG [%d] Deactivated actor %s/%s", h.num, actorType, actorID)
-		w.WriteHeader(http.StatusOK)
-	})
-	return r
-}
-
-func (h *httpServer) WaitForActorsReady(ctx context.Context) error {
-	select {
-	case <-ctx.Done():
-		return ctx.Err()
-	case <-h.actorsReadyCh:
-		return nil
-	}
-}
-
-func (i *rebalancing) getPlacementStream(t *testing.T, ctx context.Context) placementv1pb.Placement_ReportDaprStatusClient {
-	// Establish a connection with placement
-	//nolint:staticcheck
-	conn, err := grpc.DialContext(ctx, "localhost:"+strconv.Itoa(i.place.Port()),
-		grpc.WithBlock(), //nolint:staticcheck
-		grpc.WithTransportCredentials(grpcinsecure.NewCredentials()),
-	)
-	require.NoError(t, err)
-	t.Cleanup(func() { require.NoError(t, conn.Close()) })
-	client := placementv1pb.NewPlacementClient(conn)
-
-	// Establish a stream and send the initial heartbeat, with no actors
-	// We need to retry here because this will fail until the instance of
-	// placement (the only one) acquires leadership.
-	var stream placementv1pb.Placement_ReportDaprStatusClient
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		stream, err = client.ReportDaprStatus(ctx)
-		require.NoError(c, err)
-
-		pctx, cancel := context.WithTimeout(ctx, time.Second)
-		defer cancel()
-		err = i.reportStatusToPlacement(pctx, stream, []string{})
-		if !assert.NoError(c, err) {
-			stream.CloseSend()
-			stream = nil
-		}
-	}, time.Second*20, time.Millisecond*10)
-
-	return stream
-}
-
-func (i *rebalancing) reportStatusToPlacement(ctx context.Context, stream placementv1pb.Placement_ReportDaprStatusClient, entities []string) error {
-	err := stream.Send(&placementv1pb.Host{
-		Name:     "invalidapp",
-		Port:     1234,
-		Entities: entities,
-		Id:       "invalidapp",
-		ApiLevel: 20,
-	})
-	if err != nil {
-		return fmt.Errorf("failed to send message: %w", err)
-	}
-
-	errCh := make(chan error, 1)
-	go func() {
-		for {
-			// When the stream ends (which happens when the context is canceled) this returns an error and we can return
-			o, rerr := stream.Recv()
-			if rerr != nil {
-				errCh <- fmt.Errorf("error from placement: %w", rerr)
-				return
-			}
-			if o.GetOperation() == "update" {
-				errCh <- nil
-				return
-			}
-		}
-	}()
-
-	select {
-	case <-ctx.Done():
-		return ctx.Err()
-	case err = <-errCh:
-		return err
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/reminders.go b/tests/integration/suite/actors/reminders/reminders.go
deleted file mode 100644
index 352b467bd..000000000
--- a/tests/integration/suite/actors/reminders/reminders.go
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/failurepolicy"
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/migration"
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/scheduler"
-	_ "github.com/dapr/dapr/tests/integration/suite/actors/reminders/serialization"
-)
diff --git a/tests/integration/suite/actors/reminders/scheduler/basic.go b/tests/integration/suite/actors/reminders/scheduler/basic.go
deleted file mode 100644
index aae04711e..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/basic.go
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strings"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	procscheduler "github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(basic))
-}
-
-type basic struct {
-	daprd     *daprd.Daprd
-	place     *placement.Placement
-	scheduler *procscheduler.Scheduler
-
-	methodcalled atomic.Int64
-}
-
-func (b *basic) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
- name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/remindermethod", func(w http.ResponseWriter, r *http.Request) {
-		b.methodcalled.Add(1)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	b.scheduler = procscheduler.New(t)
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	b.place = placement.New(t)
-	b.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(b.place.Address()),
-		daprd.WithSchedulerAddresses(b.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(b.scheduler, b.place, srv, b.daprd),
-	}
-}
-
-func (b *basic) Run(t *testing.T, ctx context.Context) {
-	b.scheduler.WaitUntilRunning(t, ctx)
-	b.place.WaitUntilRunning(t, ctx)
-	b.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	aurl := b.daprd.ActorInvokeURL("myactortype", "myactorid", "foo")
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, aurl, nil)
-	require.NoError(t, err)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		resp, rErr := client.Do(req)
-		if assert.NoError(c, rErr) {
-			assert.NoError(c, resp.Body.Close())
-			assert.Equal(c, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-
-	body := `{"dueTime": "1s", "data": "reminderdata"}`
-	aurl = b.daprd.ActorReminderURL("myactortype", "myactorid", "remindermethod")
-	req, err = http.NewRequestWithContext(ctx, http.MethodPost, aurl, strings.NewReader(body))
-	require.NoError(t, err)
-
-	resp, err := client.Do(req)
-	require.NoError(t, err)
-	require.NoError(t, resp.Body.Close())
-	assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-
-	assert.Eventually(t, func() bool {
-		return b.methodcalled.Load() == 1
-	}, time.Second*3, time.Millisecond*10)
-
-	gclient := b.daprd.GRPCClient(t, ctx)
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "remindermethod",
-		DueTime:   "1s",
-		Data:      []byte("reminderdata"),
-	})
-	require.NoError(t, err)
-
-	assert.Eventually(t, func() bool {
-		return b.methodcalled.Load() == 2
-	}, time.Second*10, time.Millisecond*10)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/data.go b/tests/integration/suite/actors/reminders/scheduler/data.go
deleted file mode 100644
index d8a7094e1..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/data.go
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(data))
-}
-
-type data struct {
-	actors *actors.Actors
-	got    chan string
-}
-
-func (d *data) Setup(t *testing.T) []framework.Option {
-	d.got = make(chan string, 1)
-	d.actors = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(_ http.ResponseWriter, req *http.Request) {
-			if req.Method == http.MethodDelete {
-				return
-			}
-			got, err := io.ReadAll(req.Body)
-			assert.NoError(t, err)
-			d.got <- string(got)
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(d.actors),
-	}
-}
-
-func (d *data) Run(t *testing.T, ctx context.Context) {
-	d.actors.WaitUntilRunning(t, ctx)
-
-	_, err := d.actors.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "foo",
-		ActorId:   "1234",
-		Name:      "helloworld",
-		DueTime:   "0s",
-		Period:    "1000s",
-		Ttl:       "2000s",
-		Data:      []byte("mydata"),
-	})
-	require.NoError(t, err)
-
-	select {
-	case got := <-d.got:
-		assert.JSONEq(t, `{"data":"bXlkYXRh","dueTime":"","period":""}`, got)
-	case <-time.After(10 * time.Second):
-		t.Fatal("timed out waiting for reminder")
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/duetime.go b/tests/integration/suite/actors/reminders/scheduler/duetime.go
deleted file mode 100644
index b660763be..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/duetime.go
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/credentials/insecure"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(duetime))
-}
-
-type duetime struct {
-	daprd *daprd.Daprd
-	place *placement.Placement
-
-	reminderCalled     atomic.Int64
-	stopReminderCalled atomic.Int64
-}
-
-func (d *duetime) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/remindermethod", func(w http.ResponseWriter, r *http.Request) {
-		d.reminderCalled.Add(1)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/stopreminder", func(w http.ResponseWriter, r *http.Request) {
-		d.stopReminderCalled.Add(1)
-		w.Header().Set("X-DaprReminderCancel", "true")
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	scheduler := scheduler.New(t)
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	d.place = placement.New(t)
-	d.daprd = daprd.New(t,
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithAppPort(srv.Port()),
-		daprd.WithSchedulerAddresses(scheduler.Address()),
-		daprd.WithConfigs(configFile),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(scheduler, d.place, srv, d.daprd),
-	}
-}
-
-func (d *duetime) Run(t *testing.T, ctx context.Context) {
-	d.place.WaitUntilRunning(t, ctx)
-	d.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://localhost:" + strconv.Itoa(d.daprd.HTTPPort()) + "/v1.0/actors/myactortype/myactorid"
-
-	t.Run("actor ready", func(t *testing.T) {
-		req, err := http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/method/foo", nil)
-		require.NoError(t, err)
-
-		require.EventuallyWithT(t, func(c *assert.CollectT) {
-			resp, rErr := client.Do(req)
-			if assert.NoError(c, rErr) {
-				assert.NoError(c, resp.Body.Close())
-				assert.Equal(c, http.StatusOK, resp.StatusCode)
-			}
-		}, 10*time.Second, 10*time.Millisecond, "actor not ready in time")
-	})
-
-	//nolint:staticcheck
-	conn, err := grpc.DialContext(ctx, d.daprd.GRPCAddress(),
-		grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock(),
-	)
-	require.NoError(t, err)
-	t.Cleanup(func() { require.NoError(t, conn.Close()) })
-	gclient := rtv1.NewDaprClient(conn)
-
-	t.Run("schedule reminder via gRPC", func(t *testing.T) {
-		_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      "remindermethod",
-			DueTime:   "0s",
-			Period:    "PT1M",
-		})
-		require.NoError(t, err)
-
-		assert.Eventually(t, func() bool {
-			return d.reminderCalled.Load() == 1
-		}, 3*time.Second, 10*time.Millisecond)
-	})
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/durable.go b/tests/integration/suite/actors/reminders/scheduler/durable.go
deleted file mode 100644
index b56454b95..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/durable.go
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"path"
-	"strconv"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(durable))
-}
-
-type durable struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-	triggered slice.Slice[string]
-
-	daprd1 *daprd.Daprd
-	daprd2 *daprd.Daprd
-}
-
-func (d *durable) Setup(t *testing.T) []framework.Option {
-	d.triggered = slice.String()
-
-	app := app.New(t,
-		app.WithHandlerFunc("/", func(_ http.ResponseWriter, r *http.Request) {}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(_ http.ResponseWriter, r *http.Request) {
-		}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/remind/", func(_ http.ResponseWriter, r *http.Request) {
-			d.triggered.Append(path.Base(r.URL.Path))
-		}),
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-	)
-
-	d.scheduler = scheduler.New(t)
-	d.place = placement.New(t)
-
-	opts := []daprd.Option{
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(d.place.Address()),
-		daprd.WithAppPort(app.Port()),
-		daprd.WithSchedulerAddresses(d.scheduler.Address()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`),
-	}
-
-	d.daprd1 = daprd.New(t, opts...)
-	d.daprd2 = daprd.New(t, opts...)
-
-	return []framework.Option{
-		framework.WithProcesses(app, d.scheduler, d.place),
-	}
-}
-
-func (d *durable) Run(t *testing.T, ctx context.Context) {
-	d.place.WaitUntilRunning(t, ctx)
-	d.scheduler.WaitUntilRunning(t, ctx)
-
-	d.daprd1.Run(t, ctx)
-	t.Cleanup(func() { d.daprd1.Cleanup(t) })
-	d.daprd1.WaitUntilRunning(t, ctx)
-
-	sec3 := time.Now().Add(time.Second * 2).Format(time.RFC3339)
-
-	client := d.daprd1.GRPCClient(t, ctx)
-	for i := range 20 {
-		_, err := client.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      strconv.Itoa(i),
-			DueTime:   sec3,
-			Data:      []byte("hello"),
-			Period:    "R2/PT3S",
-		})
-		require.NoError(t, err)
-	}
-
-	exp := []string{
-		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
-		"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
-	}
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, exp, d.triggered.Slice())
-	}, time.Second*20, time.Millisecond*10)
-
-	d.daprd1.Cleanup(t)
-
-	d.daprd2.Run(t, ctx)
-	t.Cleanup(func() { d.daprd2.Cleanup(t) })
-	d.daprd2.WaitUntilRunning(t, ctx)
-
-	exp = []string{
-		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
-		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
-		"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
-		"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
-	}
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, exp, d.triggered.Slice())
-	}, time.Second*20, time.Millisecond*10)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/get.go b/tests/integration/suite/actors/reminders/scheduler/get.go
deleted file mode 100644
index 0d0a53a82..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/get.go
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"strings"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(get))
-}
-
-type get struct {
-	actors *actors.Actors
-}
-
-func (g *get) Setup(t *testing.T) []framework.Option {
-	g.actors = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(http.ResponseWriter, *http.Request) {}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(g.actors),
-	}
-}
-
-func (g *get) Run(t *testing.T, ctx context.Context) {
-	g.actors.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	url := g.actors.Daprd().ActorReminderURL("foo", "1234", "helloworld")
-	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
-	require.NoError(t, err)
-	resp, err := client.Do(req)
-	require.NoError(t, err)
-	// Not found returns 200.
-	assert.Equal(t, http.StatusOK, resp.StatusCode)
-	require.NoError(t, resp.Body.Close())
-
-	body := `{"data":"reminderdata","dueTime":"1s","period":"1s"}`
-	req, err = http.NewRequestWithContext(ctx, http.MethodPost, url, strings.NewReader(body))
-	require.NoError(t, err)
-	resp, err = client.Do(req)
-	require.NoError(t, err)
-	assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-	require.NoError(t, resp.Body.Close())
-
-	req, err = http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
-	require.NoError(t, err)
-	resp, err = client.Do(req)
-	require.NoError(t, err)
-	assert.Equal(t, http.StatusOK, resp.StatusCode)
-	b, err := io.ReadAll(resp.Body)
-	require.NoError(t, err)
-	require.NoError(t, resp.Body.Close())
-	assert.JSONEq(t, `{"period":"@every 1s","data":"reminderdata","actorID":"1234","actorType":"foo","dueTime":"1s"}`, strings.TrimSpace(string(b)))
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/hdata.go b/tests/integration/suite/actors/reminders/scheduler/hdata.go
deleted file mode 100644
index 2ab8eb982..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/hdata.go
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"io"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"strings"
-	"sync"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(hdata))
-}
-
-type hdata struct {
-	daprd     *daprd.Daprd
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	lock sync.Mutex
-	data map[string]chan string
-}
-
-func (h *hdata) Setup(t *testing.T) []framework.Option {
-	h.data = make(map[string]chan string)
-
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
- name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/{id}", func(w http.ResponseWriter, r *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/{id}/method/remind/", func(w http.ResponseWriter, r *http.Request) {
-		b, err := io.ReadAll(r.Body)
-		assert.NoError(t, err)
-		h.lock.Lock()
-		ch := h.data[r.PathValue("id")]
-		h.lock.Unlock()
-		ch <- string(b)
-	})
-	handler.HandleFunc("/actors/myactortype/{id}/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	h.scheduler = scheduler.New(t)
-	h.place = placement.New(t)
-	h.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(h.place.Address()),
-		daprd.WithSchedulerAddresses(h.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(h.scheduler, h.place, srv, h.daprd),
-	}
-}
-
-func (h *hdata) Run(t *testing.T, ctx context.Context) {
-	h.place.WaitUntilRunning(t, ctx)
-	h.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	aurl := h.daprd.ActorInvokeURL("myactortype", "myactorid", "foo")
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, aurl, nil)
-	require.NoError(t, err)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		resp, rErr := client.Do(req)
-		if assert.NoError(c, rErr) {
-			assert.NoError(c, resp.Body.Close())
-			assert.Equal(c, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-
-	gclient := h.daprd.GRPCClient(t, ctx)
-
-	tests := map[string]struct {
-		expHTTP string
-		expGRPC string
-	}{
-		``: {
-			`{"dueTime":"","period":""}`,
-			`{"dueTime":"","period":""}`,
-		},
-		`"foo"`: {
-			`{"data":"foo","dueTime":"","period":""}`,
-			`{"data":"ImZvbyI=","dueTime":"","period":""}`,
-		},
-		`{  "foo": [ 12, 4 ] }`: {
-			`{"data":{"foo":[12,4]},"dueTime":"","period":""}`,
-			`{"data":"eyAgImZvbyI6IFsgMTIsIDQgXSB9","dueTime":"","period":""}`,
-		},
-		`true`: {
-			`{"data":true,"dueTime":"","period":""}`,
-			`{"data":"dHJ1ZQ==","dueTime":"","period":""}`,
-		},
-		`null`: {
-			`{"data":null,"dueTime":"","period":""}`,
-			`{"data":"bnVsbA==","dueTime":"","period":""}`,
-		},
-		`[]`: {
-			`{"data":[],"dueTime":"","period":""}`,
-			`{"data":"W10=","dueTime":"","period":""}`,
-		},
-		`123`: {
-			`{"data":123,"dueTime":"","period":""}`,
-			`{"data":"MTIz","dueTime":"","period":""}`,
-		},
-	}
-
-	var i atomic.Int64
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			actorID := strconv.FormatInt(i.Add(1), 10)
-			h.lock.Lock()
-			ch := make(chan string, 1)
-			h.data[actorID] = ch
-			h.lock.Unlock()
-
-			body := `{"dueTime": "0s"`
-			if name != `` {
-				body += `,"data": ` + name
-			}
-			body += `}`
-			aurl := h.daprd.ActorReminderURL("myactortype", actorID, "remindermethod-http")
-			req, err := http.NewRequestWithContext(ctx, http.MethodPost, aurl, strings.NewReader(body))
-			require.NoError(t, err)
-
-			resp, err := client.Do(req)
-			require.NoError(t, err)
-			require.NoError(t, resp.Body.Close())
-			assert.Equal(t, http.StatusNoContent, resp.StatusCode)
-			select {
-			case got := <-ch:
-				assert.Equal(t, test.expHTTP, got, name)
-			case <-time.After(time.Second * 10):
-				require.Fail(t, "timeout waiting for reminder")
-			}
-
-			_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-				ActorType: "myactortype",
-				ActorId:   actorID,
-				Name:      "remindermethod-grpc",
-				DueTime:   "0s",
-				Data:      []byte(name),
-			})
-			require.NoError(t, err)
-			select {
-			case got := <-ch:
-				assert.Equal(t, test.expGRPC, got, name)
-			case <-time.After(time.Second * 10):
-				require.Fail(t, "timeout waiting for reminder")
-			}
-		})
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/hop.go b/tests/integration/suite/actors/reminders/scheduler/hop.go
deleted file mode 100644
index 0382a8062..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/hop.go
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	procscheduler "github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(hop))
-}
-
-type hop struct {
-	daprd1    *daprd.Daprd
-	daprd2    *daprd.Daprd
-	place     *placement.Placement
-	scheduler *procscheduler.Scheduler
-
-	daprd1called atomic.Uint64
-	daprd2called atomic.Uint64
-}
-
-func (h *hop) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	newHTTP := func(called *atomic.Uint64) *prochttp.HTTP {
-		handler := http.NewServeMux()
-		handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(`{"entities": ["myactortype"]}`))
-		})
-		handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-			w.WriteHeader(http.StatusOK)
-		})
-
-		handler.HandleFunc("/actors/myactortype/foo", func(http.ResponseWriter, *http.Request) {
-		})
-
-		for i := range 100 {
-			handler.HandleFunc("/actors/myactortype/foo/method/remind/"+strconv.Itoa(i), func(http.ResponseWriter, *http.Request) {
-				called.Add(1)
-			})
-		}
-
-		return prochttp.New(t, prochttp.WithHandler(handler))
-	}
-
-	h.scheduler = procscheduler.New(t)
-	h.place = placement.New(t)
-
-	srv1 := newHTTP(&h.daprd1called)
-	srv2 := newHTTP(&h.daprd2called)
-	h.daprd1 = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(h.place.Address()),
-		daprd.WithSchedulerAddresses(h.scheduler.Address()),
-		daprd.WithAppPort(srv1.Port()),
-	)
-	h.daprd2 = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(h.place.Address()),
-		daprd.WithSchedulerAddresses(h.scheduler.Address()),
-		daprd.WithAppPort(srv2.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(srv1, srv2, h.scheduler, h.place, h.daprd1, h.daprd2),
-	}
-}
-
-func (h *hop) Run(t *testing.T, ctx context.Context) {
-	h.scheduler.WaitUntilRunning(t, ctx)
-	h.place.WaitUntilRunning(t, ctx)
-	h.daprd1.WaitUntilRunning(t, ctx)
-	h.daprd2.WaitUntilRunning(t, ctx)
-
-	gclient := h.daprd1.GRPCClient(t, ctx)
-	for i := range 100 {
-		_, err := gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "foo",
-			Name:      strconv.Itoa(i),
-			DueTime:   "0s",
-			Data:      []byte("reminderdata"),
-		})
-		require.NoError(t, err, "failed to register reminder iteration"+strconv.Itoa(i))
-	}
-
-	assert.Eventually(t, func() bool {
-		return h.daprd1called.Load() == 100 || h.daprd2called.Load() == 100
-	}, time.Second*10, time.Millisecond*10)
-
-	assert.True(t,
-		(h.daprd1called.Load() == 100 && h.daprd2called.Load() == 0) ||
-			(h.daprd2called.Load() == 100 && h.daprd1called.Load() == 0),
-	)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/idtypes.go b/tests/integration/suite/actors/reminders/scheduler/idtypes.go
deleted file mode 100644
index 6a30f5836..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/idtypes.go
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"os"
-	"path/filepath"
-	"sync"
-	"testing"
-	"time"
-
-	"github.com/google/uuid"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(idtype))
-}
-
-type actordaprd struct {
-	actorTypes []actortype
-}
-
-type actortype struct {
-	typename string
-	ids      []string
-}
-
-type idtype struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	actorTypesNum int
-	actorIDsNum   int
-	daprdsNum     int
-
-	daprds      []*daprd.Daprd
-	actorDaprds []actordaprd
-
-	lock         sync.Mutex
-	methodcalled []string
-	expcalled    []string
-}
-
-func (i *idtype) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	i.scheduler = scheduler.New(t)
-	i.place = placement.New(t)
-
-	i.daprdsNum = 4
-	i.actorTypesNum = 2
-	i.actorIDsNum = 15
-	i.daprds = make([]*daprd.Daprd, i.daprdsNum)
-	i.actorDaprds = make([]actordaprd, i.daprdsNum)
-	procs := make([]process.Interface, i.daprdsNum*2+2)
-	procs[0] = i.scheduler
-	procs[1] = i.place
-
-	for x := range i.daprdsNum {
-		i.actorDaprds[x].actorTypes = make([]actortype, i.actorTypesNum)
-
-		var appOpts []app.Option
-		for y := range i.actorTypesNum {
-			typeuid, err := uuid.NewUUID()
-			require.NoError(t, err)
-			i.actorDaprds[x].actorTypes[y].typename = typeuid.String()
-			i.actorDaprds[x].actorTypes[y].ids = make([]string, i.actorIDsNum)
-
-			for z := range i.actorIDsNum {
-				iduid, err := uuid.NewUUID()
-				require.NoError(t, err)
-				i.actorDaprds[x].actorTypes[y].ids[z] = iduid.String()
-				i.expcalled = append(i.expcalled, fmt.Sprintf("%d/%s/%s", x, typeuid.String(), iduid.String()))
-
-				appOpts = append(appOpts,
-					app.WithHandlerFunc(
-						fmt.Sprintf("/actors/%s/%s", typeuid.String(), iduid.String()), func(http.ResponseWriter, *http.Request) {}),
-					app.WithHandlerFunc(
-						fmt.Sprintf("/actors/%s/%s/method/remind/", typeuid.String(), iduid.String()),
-						func(http.ResponseWriter, *http.Request) {
-							i.lock.Lock()
-							defer i.lock.Unlock()
-							i.methodcalled = append(i.methodcalled, fmt.Sprintf("%d/%s/%s", x, typeuid.String(), iduid.String()))
-						}),
-					app.WithHandlerFunc(
-						fmt.Sprintf("/actors/%s/%s/method/foo", typeuid.String(), iduid.String()),
-						func(http.ResponseWriter, *http.Request) {},
-					),
-				)
-			}
-		}
-
-		app := app.New(t, append(appOpts,
-			app.WithHandlerFunc("/dapr/config",
-				func(w http.ResponseWriter, r *http.Request) {
-					fmt.Fprintf(w, `{"entities": ["%s", "%s"]}`,
-						i.actorDaprds[x].actorTypes[0].typename,
-						i.actorDaprds[x].actorTypes[1].typename,
-					)
-				}),
-		)...)
-
-		i.daprds[x] = daprd.New(t,
-			daprd.WithConfigs(configFile),
-			daprd.WithInMemoryActorStateStore("mystore"),
-			daprd.WithPlacementAddresses(i.place.Address()),
-			daprd.WithSchedulerAddresses(i.scheduler.Address()),
-			daprd.WithAppPort(app.Port()),
-		)
-
-		procs[2+x*2] = app
-		procs[2+x*2+1] = i.daprds[x]
-	}
-
-	return []framework.Option{
-		framework.WithProcesses(procs...),
-	}
-}
-
-func (i *idtype) Run(t *testing.T, ctx context.Context) {
-	i.scheduler.WaitUntilRunning(t, ctx)
-	i.place.WaitUntilRunning(t, ctx)
-
-	for x := range i.daprdsNum {
-		i.daprds[x].WaitUntilRunning(t, ctx)
-	}
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://" + i.daprds[0].HTTPAddress() + "/v1.0/actors/"
-	for x := range i.daprdsNum {
-		for y := range i.actorTypesNum {
-			for z := range i.actorIDsNum {
-				require.EventuallyWithT(t, func(c *assert.CollectT) {
-					invoke := fmt.Sprintf("%s/%s/%s/method/foo", daprdURL, i.actorDaprds[x].actorTypes[y].typename, i.actorDaprds[x].actorTypes[y].ids[z])
-					req, err := http.NewRequestWithContext(ctx, http.MethodPost, invoke, nil)
-					require.NoError(c, err)
-					resp, err := client.Do(req)
-					if assert.NoError(c, err) {
-						assert.NoError(c, resp.Body.Close())
-						assert.Equal(c, http.StatusOK, resp.StatusCode)
-					}
-				}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-			}
-		}
-	}
-
-	for x := range i.daprdsNum {
-		for y := range i.actorTypesNum {
-			for z := range i.actorIDsNum {
-				_, err := i.daprds[x].GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-					ActorType: i.actorDaprds[x].actorTypes[y].typename,
-					ActorId:   i.actorDaprds[x].actorTypes[y].ids[z],
-					Name:      "remindermethod",
-					DueTime:   "1s",
-					Period:    "10000s",
-					Data:      []byte("reminderdata"),
-				})
-				require.NoError(t, err)
-			}
-		}
-	}
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		i.lock.Lock()
-		defer i.lock.Unlock()
-		assert.Len(c, i.methodcalled, i.actorIDsNum*i.actorTypesNum*i.daprdsNum)
-	}, time.Second*20, time.Millisecond*10)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		i.lock.Lock()
-		defer i.lock.Unlock()
-		assert.ElementsMatch(c, i.expcalled, i.methodcalled)
-	}, time.Second*30, time.Millisecond*10)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/nostore.go b/tests/integration/suite/actors/reminders/scheduler/nostore.go
deleted file mode 100644
index 14d968ced..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/nostore.go
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"fmt"
-	"io"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strings"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(nostore))
-}
-
-type nostore struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	daprd *daprd.Daprd
-}
-
-func (n *nostore) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	n.scheduler = scheduler.New(t)
-
-	app := app.New(t,
-		app.WithHandlerFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(`{"entities": ["foo"]}`))
-		}),
-		app.WithHandlerFunc("/actors/", func(http.ResponseWriter, *http.Request) {}),
-	)
-
-	n.place = placement.New(t)
-
-	n.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithPlacementAddresses(n.place.Address()),
-		daprd.WithSchedulerAddresses(n.scheduler.Address()),
-		daprd.WithAppPort(app.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(app, n.scheduler, n.place, n.daprd),
-	}
-}
-
-func (n *nostore) Run(t *testing.T, ctx context.Context) {
-	n.scheduler.WaitUntilRunning(t, ctx)
-	n.place.WaitUntilRunning(t, ctx)
-	n.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	for method, test := range map[string]struct {
-		body string
-		err  string
-	}{
-		http.MethodPost: {
-			body: `{"dueTime": "100s"}`,
-			err:  `{"errorCode":"ERR_ACTOR_REMINDER_CREATE","message":"error creating actor reminder: reminder storage is not configured"}`,
-		},
-		http.MethodGet: {
-			body: `{"dueTime": "100s"}`,
-			err:  `{"errorCode":"ERR_ACTOR_REMINDER_GET","message":"error getting actor reminder: reminder storage is not configured"}`,
-		},
-		http.MethodDelete: {
-			body: `{"dueTime": "100s"}`,
-			err:  `{"errorCode":"ERR_ACTOR_REMINDER_DELETE","message":"error deleting actor reminder: reminder storage is not configured"}`,
-		},
-	} {
-		var bodyReader io.Reader
-		if test.body != "" {
-			bodyReader = strings.NewReader(test.body)
-		}
-
-		req, err := http.NewRequestWithContext(ctx, method,
-			fmt.Sprintf("http://%s/v1.0/actors/foo/bar/reminders/newreminder", n.daprd.HTTPAddress()),
-			bodyReader,
-		)
-		require.NoError(t, err)
-		resp, err := client.Do(req)
-		require.NoError(t, err)
-		assert.Equal(t, http.StatusInternalServerError, resp.StatusCode)
-		body, err := io.ReadAll(resp.Body)
-		require.NoError(t, err)
-		require.NoError(t, resp.Body.Close())
-		assert.JSONEq(t, test.err, string(body))
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/precision.go b/tests/integration/suite/actors/reminders/scheduler/precision.go
deleted file mode 100644
index 9221a302c..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/precision.go
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
-Copyright 2025 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(precision))
-}
-
-type precision struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-	daprd     *daprd.Daprd
-	called    slice.Slice[*request]
-}
-
-type request struct {
-	name          string
-	executionTime time.Time
-}
-
-func (r *precision) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	r.called = slice.New[*request]()
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/sec", func(http.ResponseWriter, *http.Request) {
-		r.called.Append(&request{
-			name:          "sec",
-			executionTime: time.Now(),
-		})
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/ms", func(http.ResponseWriter, *http.Request) {
-		r.called.Append(&request{
-			name:          "ms",
-			executionTime: time.Now(),
-		})
-	})
-
-	r.scheduler = scheduler.New(t)
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	r.place = placement.New(t)
-	r.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(r.scheduler, r.place, srv, r.daprd),
-	}
-}
-
-func (r *precision) Run(t *testing.T, ctx context.Context) {
-	r.scheduler.WaitUntilRunning(t, ctx)
-	r.place.WaitUntilRunning(t, ctx)
-	r.daprd.WaitUntilRunning(t, ctx)
-
-	gclient := r.daprd.GRPCClient(t, ctx)
-	_, err := gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "sec",
-		Data:      []byte("reminderdata"),
-		Period:    "1s",
-		Ttl:       "5s",
-	})
-	require.NoError(t, err)
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "ms",
-		Data:      []byte("reminderdata"),
-		Period:    "1ms",
-		Ttl:       "10ms",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Len(c, r.called.Slice(), 15)
-	}, time.Second*10, time.Millisecond*10)
-
-	eMap := make(map[string][]*request)
-	for _, v := range r.called.Slice() {
-		eMap[v.name] = append(eMap[v.name], v)
-	}
-
-	tolerance := 500 * time.Millisecond
-	assertDurationWithTolerance(t, eMap, "sec", 1*time.Second, float64(tolerance))
-	assertDurationWithTolerance(t, eMap, "ms", time.Millisecond, float64(tolerance))
-}
-
-func assertDurationWithTolerance(t *testing.T, values map[string][]*request, key string, expectedDiff time.Duration, tolerance float64) {
-	var prevTime time.Time
-	for i, e := range values[key] {
-		if prevTime.IsZero() {
-			prevTime = e.executionTime
-			continue
-		}
-
-		actualDiff := e.executionTime.Sub(prevTime)
-
-		// Check if the difference is within tolerance
-		assert.InDeltaf(t, expectedDiff, actualDiff, tolerance, "[%v]Expected execution time difference to be %v  %v, but got %v", i,
-			expectedDiff, tolerance, actualDiff)
-
-		prevTime = e.executionTime
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/reminder.go b/tests/integration/suite/actors/reminders/scheduler/reminder.go
deleted file mode 100644
index b70c0bfd9..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/reminder.go
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/exec"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/logline"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(reminder))
-}
-
-type reminder struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	daprd        *daprd.Daprd
-	methodcalled atomic.Uint32
-
-	loglineSchedulerReminders *logline.LogLine
-}
-
-func (r *reminder) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	r.loglineSchedulerReminders = logline.New(t, logline.WithStdoutLineContains(
-		"Using Scheduler service for reminders.",
-	))
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/xyz", func(http.ResponseWriter, *http.Request) {
-		r.methodcalled.Add(1)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(http.ResponseWriter, *http.Request) {})
-
-	r.scheduler = scheduler.New(t)
-
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-
-	r.place = placement.New(t)
-
-	r.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-		daprd.WithAppProtocol("http"),
-		daprd.WithLogLevel("debug"),
-		daprd.WithExecOptions(
-			exec.WithStdout(r.loglineSchedulerReminders.Stdout()),
-		))
-
-	return []framework.Option{
-		framework.WithProcesses(r.loglineSchedulerReminders, r.scheduler, r.place, srv, r.daprd),
-	}
-}
-
-func (r *reminder) Run(t *testing.T, ctx context.Context) {
-	r.scheduler.WaitUntilRunning(t, ctx)
-	r.place.WaitUntilRunning(t, ctx)
-	r.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://" + r.daprd.HTTPAddress() + "/v1.0/actors/myactortype/myactorid"
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/method/foo", nil)
-	require.NoError(t, err)
-
-	require.EventuallyWithT(t, func(r *assert.CollectT) {
-		resp, rErr := client.Do(req)
-		if assert.NoError(r, rErr) {
-			assert.NoError(r, resp.Body.Close())
-			assert.Equal(r, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-
-	gclient := r.daprd.GRPCClient(t, ctx)
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-		DueTime:   "1s",
-	})
-	require.NoError(t, err)
-
-	assert.Eventually(t, func() bool {
-		return r.methodcalled.Load() == 1
-	}, time.Second*5, time.Millisecond*10)
-
-	// ensure we are using scheduler for reminders if preview feature is set
-	r.loglineSchedulerReminders.EventuallyFoundAll(t)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/remote.go b/tests/integration/suite/actors/reminders/scheduler/remote.go
deleted file mode 100644
index e5c266656..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/remote.go
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"os"
-	"path/filepath"
-	"sync"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/google/uuid"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	procscheduler "github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(remote))
-}
-
-type remote struct {
-	daprd1    *daprd.Daprd
-	daprd2    *daprd.Daprd
-	place     *placement.Placement
-	scheduler *procscheduler.Scheduler
-
-	daprd1called atomic.Uint64
-	daprd2called atomic.Uint64
-
-	actorIDsNum int
-	actorIDs    []string
-
-	lock         sync.Mutex
-	methodcalled atomic.Value
-}
-
-func (r *remote) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	r.actorIDsNum = 100
-	r.methodcalled.Store(make([]string, 0, r.actorIDsNum))
-	r.actorIDs = make([]string, r.actorIDsNum)
-	for i := range r.actorIDsNum {
-		uid, err := uuid.NewUUID()
-		require.NoError(t, err)
-		r.actorIDs[i] = uid.String()
-	}
-
-	newHTTP := func(called *atomic.Uint64) *prochttp.HTTP {
-		handler := http.NewServeMux()
-		handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(`{"entities": ["myactortype"]}`))
-		})
-		handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-			w.WriteHeader(http.StatusOK)
-		})
-
-		for _, id := range r.actorIDs {
-			handler.HandleFunc("/actors/myactortype/"+id, func(http.ResponseWriter, *http.Request) {
-			})
-			handler.HandleFunc(fmt.Sprintf("/actors/myactortype/%s/method/remind/remindermethod", id), func(http.ResponseWriter, *http.Request) {
-				r.lock.Lock()
-				defer r.lock.Unlock()
-				r.methodcalled.Store(append(r.methodcalled.Load().([]string), id))
-				called.Add(1)
-			})
-			handler.HandleFunc(fmt.Sprintf("/actors/myactortype/%s/method/foo", id), func(http.ResponseWriter, *http.Request) {})
-		}
-
-		return prochttp.New(t, prochttp.WithHandler(handler))
-	}
-
-	r.scheduler = procscheduler.New(t)
-	r.place = placement.New(t)
-
-	srv1 := newHTTP(&r.daprd1called)
-	srv2 := newHTTP(&r.daprd2called)
-	r.daprd1 = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(srv1.Port()),
-	)
-	r.daprd2 = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(srv2.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(srv1, srv2, r.scheduler, r.place, r.daprd1, r.daprd2),
-	}
-}
-
-func (r *remote) Run(t *testing.T, ctx context.Context) {
-	r.scheduler.WaitUntilRunning(t, ctx)
-	r.place.WaitUntilRunning(t, ctx)
-	r.daprd1.WaitUntilRunning(t, ctx)
-	r.daprd2.WaitUntilRunning(t, ctx)
-
-	gclient := r.daprd1.GRPCClient(t, ctx)
-	for _, id := range r.actorIDs {
-		_, err := gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   id,
-			Name:      "remindermethod",
-			DueTime:   "1s",
-			Data:      []byte("reminderdata"),
-		})
-		require.NoError(t, err)
-	}
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		r.lock.Lock()
-		defer r.lock.Unlock()
-		assert.Len(c, r.methodcalled.Load().([]string), r.actorIDsNum)
-	}, time.Second*5, time.Millisecond*10)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, r.actorIDs, r.methodcalled.Load().([]string))
-	}, time.Second*10, time.Millisecond*10)
-
-	assert.GreaterOrEqual(t, r.daprd1called.Load(), uint64(0))
-	assert.GreaterOrEqual(t, r.daprd2called.Load(), uint64(0))
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/remove.go b/tests/integration/suite/actors/reminders/scheduler/remove.go
deleted file mode 100644
index b49f4d511..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/remove.go
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"os"
-	"path/filepath"
-	"strconv"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	runtimev1pb "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/ports"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(remove))
-}
-
-type remove struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-	triggered atomic.Int64
-
-	daprd *daprd.Daprd
-}
-
-func (r *remove) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	fp := ports.Reserve(t, 2)
-	port1 := fp.Port(t)
-	port2 := fp.Port(t)
-	r.scheduler = scheduler.New(t,
-		scheduler.WithID("scheduler-0"),
-		scheduler.WithInitialCluster(fmt.Sprintf("scheduler-0=http://localhost:%d", port1)),
-		scheduler.WithEtcdClientPort(port2),
-	)
-
-	app := app.New(t,
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {
-		}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/remind/remindermethod", func(http.ResponseWriter, *http.Request) {
-			r.triggered.Add(1)
-		}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/foo", func(http.ResponseWriter, *http.Request) {}),
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-	)
-
-	r.place = placement.New(t)
-
-	r.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(app.Port()),
-	)
-
-	fp.Free(t)
-	return []framework.Option{
-		framework.WithProcesses(app, r.scheduler, r.place, r.daprd),
-	}
-}
-
-func (r *remove) Run(t *testing.T, ctx context.Context) {
-	r.scheduler.WaitUntilRunning(t, ctx)
-	r.place.WaitUntilRunning(t, ctx)
-	r.daprd.WaitUntilRunning(t, ctx)
-
-	client := r.daprd.GRPCClient(t, ctx)
-
-	// should have the same path separator across OS
-	etcdKeysPrefix := "dapr/jobs"
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Empty(c, r.scheduler.ListAllKeys(t, ctx, etcdKeysPrefix))
-	}, time.Second*10, 10*time.Millisecond)
-
-	_, err := client.InvokeActor(ctx, &runtimev1pb.InvokeActorRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Method:    "foo",
-	})
-	require.NoError(t, err)
-
-	_, err = client.RegisterActorReminder(ctx, &runtimev1pb.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "remindermethod",
-		DueTime:   "0s",
-		Period:    "1s",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Len(c, r.scheduler.ListAllKeys(t, ctx, etcdKeysPrefix), 1)
-	}, time.Second*10, 10*time.Millisecond)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.GreaterOrEqual(c, r.triggered.Load(), int64(1))
-	}, 30*time.Second, 10*time.Millisecond, "failed to wait for 'triggered' to be greater or equal 1, actual value "+strconv.FormatInt(r.triggered.Load(), 10))
-
-	_, err = client.UnregisterActorReminder(ctx, &runtimev1pb.UnregisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "remindermethod",
-	})
-	require.NoError(t, err)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Empty(c, r.scheduler.ListAllKeys(t, ctx, etcdKeysPrefix))
-	}, time.Second*10, 10*time.Millisecond)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/repeats.go b/tests/integration/suite/actors/reminders/scheduler/repeats.go
deleted file mode 100644
index 8bf3fc551..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/repeats.go
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/concurrency/slice"
-)
-
-func init() {
-	suite.Register(new(repeats))
-}
-
-type repeats struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-	daprd     *daprd.Daprd
-	called    slice.Slice[string]
-}
-
-func (r *repeats) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	r.called = slice.String()
-
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/pt", func(http.ResponseWriter, *http.Request) {
-		r.called.Append("pt")
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/rpt", func(http.ResponseWriter, *http.Request) {
-		r.called.Append("rpt")
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/remind/dur", func(http.ResponseWriter, *http.Request) {
-		r.called.Append("dur")
-	})
-	handler.HandleFunc("/actors/myactortype/myactorid/method/foo", func(http.ResponseWriter, *http.Request) {})
-
-	r.scheduler = scheduler.New(t)
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	r.place = placement.New(t)
-	r.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(r.place.Address()),
-		daprd.WithSchedulerAddresses(r.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(r.scheduler, r.place, srv, r.daprd),
-	}
-}
-
-func (r *repeats) Run(t *testing.T, ctx context.Context) {
-	r.scheduler.WaitUntilRunning(t, ctx)
-	r.place.WaitUntilRunning(t, ctx)
-	r.daprd.WaitUntilRunning(t, ctx)
-
-	client := client.HTTP(t)
-
-	daprdURL := "http://" + r.daprd.HTTPAddress() + "/v1.0/actors/myactortype/myactorid"
-	req, err := http.NewRequestWithContext(ctx, http.MethodPost, daprdURL+"/method/foo", nil)
-	require.NoError(t, err)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		resp, rErr := client.Do(req)
-		if assert.NoError(c, rErr) {
-			assert.NoError(c, resp.Body.Close())
-			assert.Equal(c, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*10, time.Millisecond*10, "actor not ready in time")
-
-	gclient := r.daprd.GRPCClient(t, ctx)
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "pt",
-		Data:      []byte("reminderdata"),
-		Period:    "PT1S",
-		Ttl:       "3s",
-	})
-	require.NoError(t, err)
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "rpt",
-		Data:      []byte("reminderdata"),
-		Period:    "R2/PT1S",
-	})
-	require.NoError(t, err)
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "dur",
-		Data:      []byte("reminderdata"),
-		Period:    "1s",
-		Ttl:       "3s",
-	})
-	require.NoError(t, err)
-
-	exp := []string{"pt", "pt", "pt", "rpt", "rpt", "dur", "dur", "dur"}
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.ElementsMatch(c, exp, r.called.Slice())
-	}, time.Second*10, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	assert.ElementsMatch(t, exp, r.called.Slice())
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/staging.go b/tests/integration/suite/actors/reminders/scheduler/staging.go
deleted file mode 100644
index a9f5d30bb..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/staging.go
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	schedulerv1 "github.com/dapr/dapr/pkg/proto/scheduler/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd/actors"
-	"github.com/dapr/dapr/tests/integration/suite"
-	"github.com/dapr/kit/ptr"
-)
-
-func init() {
-	suite.Register(new(staging))
-}
-
-type staging struct {
-	actors1 *actors.Actors
-	actors2 *actors.Actors
-	got     atomic.Int64
-}
-
-func (s *staging) Setup(t *testing.T) []framework.Option {
-	s.actors1 = actors.New(t,
-		actors.WithActorTypes("foo"),
-		actors.WithActorTypeHandler("foo", func(_ http.ResponseWriter, req *http.Request) {
-			assert.Fail(t, "unexpected foo call")
-		}),
-	)
-	s.actors2 = actors.New(t,
-		actors.WithDB(s.actors1.DB()),
-		actors.WithPlacement(s.actors1.Placement()),
-		actors.WithScheduler(s.actors1.Scheduler()),
-		actors.WithActorTypes("bar"),
-		actors.WithActorTypeHandler("bar", func(_ http.ResponseWriter, req *http.Request) {
-			if req.Method == http.MethodDelete {
-				return
-			}
-			s.got.Add(1)
-		}),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(s.actors1),
-	}
-}
-
-func (s *staging) Run(t *testing.T, ctx context.Context) {
-	s.actors1.WaitUntilRunning(t, ctx)
-
-	_, err := s.actors1.Scheduler().Client(t, ctx).ScheduleJob(ctx, &schedulerv1.ScheduleJobRequest{
-		Name: "helloworld",
-		Job:  &schedulerv1.Job{DueTime: ptr.Of(time.Now().Format(time.RFC3339))},
-		Metadata: &schedulerv1.JobMetadata{
-			Namespace: "default", AppId: s.actors1.AppID(),
-			Target: &schedulerv1.JobTargetMetadata{
-				Type: &schedulerv1.JobTargetMetadata_Actor{
-					Actor: &schedulerv1.TargetActorReminder{
-						Type: "bar", Id: "1234",
-					},
-				},
-			},
-		},
-	})
-	require.NoError(t, err)
-
-	time.Sleep(time.Second * 2)
-	assert.Equal(t, int64(0), s.got.Load())
-
-	t.Cleanup(func() { s.actors2.Cleanup(t) })
-	s.actors2.Run(t, ctx)
-	s.actors2.WaitUntilRunning(t, ctx)
-
-	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		assert.Equal(c, int64(1), s.got.Load())
-	}, time.Second*10, time.Millisecond*10)
-	s.actors2.Cleanup(t)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/unregister.go b/tests/integration/suite/actors/reminders/scheduler/unregister.go
deleted file mode 100644
index 4520d9557..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/unregister.go
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/status"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(unregister))
-}
-
-type unregister struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	daprd        *daprd.Daprd
-	methodcalled atomic.Uint32
-}
-
-func (u *unregister) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	app := app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/remind/xyz",
-			func(_ http.ResponseWriter, r *http.Request) { u.methodcalled.Add(1) }),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/foo", func(http.ResponseWriter, *http.Request) {}),
-	)
-
-	u.scheduler = scheduler.New(t)
-
-	u.place = placement.New(t)
-	u.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(u.place.Address()),
-		daprd.WithSchedulerAddresses(u.scheduler.Address()),
-		daprd.WithAppPort(app.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(u.scheduler, u.place, app, u.daprd),
-	}
-}
-
-func (u *unregister) Run(t *testing.T, ctx context.Context) {
-	u.scheduler.WaitUntilRunning(t, ctx)
-	u.place.WaitUntilRunning(t, ctx)
-	u.daprd.WaitUntilRunning(t, ctx)
-
-	gclient := u.daprd.GRPCClient(t, ctx)
-
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		_, err := gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-			ActorType: "myactortype",
-			ActorId:   "myactorid",
-			Name:      "xyz",
-			DueTime:   time.Now().Format(time.RFC3339),
-			Period:    "PT1S",
-		})
-		if err != nil {
-			st, ok := status.FromError(err)
-			assert.True(c, ok, "expected a gRPC status error, got %v", err)
-			assert.Equal(c, codes.Unavailable, st.Code(), "the only allowed error is 'Unavailable', but got %v", err)
-		}
-	}, time.Second*10, time.Millisecond*10)
-
-	assert.EventuallyWithT(t, func(ct *assert.CollectT) {
-		assert.GreaterOrEqual(ct, int(u.methodcalled.Load()), 2)
-	}, time.Second*5, time.Millisecond*10)
-
-	_, err := gclient.UnregisterActorReminder(ctx, &rtv1.UnregisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-	})
-	require.NoError(t, err)
-
-	time.Sleep(time.Second * 3)
-	last := u.methodcalled.Load()
-
-	assert.EventuallyWithT(t, func(ct *assert.CollectT) {
-		called := u.methodcalled.Load()
-		prevLast := last
-		last = called
-		assert.Equal(ct, int(prevLast), int(called))
-	}, time.Second*15, time.Second*2)
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-		DueTime:   time.Now().Format(time.RFC3339),
-	})
-	require.NoError(t, err)
-
-	// Sleep to give time for any ongoing call to take place.
-	time.Sleep(time.Second * 2)
-	// Last method invoke after unregister.
-	last = u.methodcalled.Load()
-
-	// Sleep some time to make sure nothing was called again.
-	time.Sleep(time.Second * 5)
-	assert.Eventually(t, func() bool {
-		return u.methodcalled.Load() == last
-	}, time.Second*20, time.Millisecond*10)
-}
diff --git a/tests/integration/suite/actors/reminders/scheduler/upsert.go b/tests/integration/suite/actors/reminders/scheduler/upsert.go
deleted file mode 100644
index 0ff523ad0..000000000
--- a/tests/integration/suite/actors/reminders/scheduler/upsert.go
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package scheduler
-
-import (
-	"context"
-	"net/http"
-	"os"
-	"path/filepath"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	"github.com/dapr/dapr/tests/integration/framework/process/http/app"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(upsert))
-}
-
-type upsert struct {
-	place     *placement.Placement
-	scheduler *scheduler.Scheduler
-
-	daprd        *daprd.Daprd
-	methodcalled atomic.Uint32
-}
-
-func (u *upsert) Setup(t *testing.T) []framework.Option {
-	configFile := filepath.Join(t.TempDir(), "config.yaml")
-	require.NoError(t, os.WriteFile(configFile, []byte(`
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: true`), 0o600))
-
-	app := app.New(t,
-		app.WithConfig(`{"entities": ["myactortype"]}`),
-		app.WithHandlerFunc("/actors/myactortype/myactorid", func(http.ResponseWriter, *http.Request) {}),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/remind/xyz",
-			func(_ http.ResponseWriter, r *http.Request) { u.methodcalled.Add(1) }),
-		app.WithHandlerFunc("/actors/myactortype/myactorid/method/foo", func(http.ResponseWriter, *http.Request) {}),
-	)
-
-	u.scheduler = scheduler.New(t)
-
-	u.place = placement.New(t)
-	u.daprd = daprd.New(t,
-		daprd.WithConfigs(configFile),
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(u.place.Address()),
-		daprd.WithSchedulerAddresses(u.scheduler.Address()),
-		daprd.WithAppPort(app.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(u.scheduler, u.place, app, u.daprd),
-	}
-}
-
-func (u *upsert) Run(t *testing.T, ctx context.Context) {
-	u.scheduler.WaitUntilRunning(t, ctx)
-	u.place.WaitUntilRunning(t, ctx)
-	u.daprd.WaitUntilRunning(t, ctx)
-
-	gclient := u.daprd.GRPCClient(t, ctx)
-	_, err := gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-		DueTime:   "1h",
-	})
-	require.NoError(t, err)
-
-	time.Sleep(time.Second * 2)
-	require.Equal(t, 0, int(u.methodcalled.Load()))
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-		DueTime:   "1s",
-	})
-	require.NoError(t, err)
-
-	assert.Eventually(t, func() bool {
-		return u.methodcalled.Load() == 1
-	}, time.Second*5, time.Millisecond*10)
-
-	time.Sleep(time.Second * 2)
-	require.Equal(t, 1, int(u.methodcalled.Load()))
-
-	_, err = gclient.RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "xyz",
-		DueTime:   time.Now().Format(time.RFC3339),
-		Period:    "PT1S",
-	})
-	require.NoError(t, err)
-
-	assert.Eventually(t, func() bool {
-		return u.methodcalled.Load() == 4
-	}, time.Second*5, time.Millisecond*10)
-}
diff --git a/tests/integration/suite/actors/reminders/serialization/common.go b/tests/integration/suite/actors/reminders/serialization/common.go
deleted file mode 100644
index ee1606fb2..000000000
--- a/tests/integration/suite/actors/reminders/serialization/common.go
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or impliei.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package serialization
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"strings"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	chi "github.com/go-chi/chi/v5"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-)
-
-func invokeActor(t *testing.T, ctx context.Context, baseURL string, client *http.Client) {
-	require.EventuallyWithT(t, func(c *assert.CollectT) {
-		req, err := http.NewRequestWithContext(ctx, http.MethodPost, baseURL+"/method/foo", nil)
-		require.NoError(c, err)
-		resp, rErr := client.Do(req)
-		if assert.NoError(c, rErr) {
-			assert.NoError(c, resp.Body.Close())
-			assert.Equal(c, http.StatusOK, resp.StatusCode)
-		}
-	}, time.Second*20, time.Millisecond*10, "actor not ready in time")
-}
-
-func storeReminder(t *testing.T, ctx context.Context, baseURL string, client *http.Client) {
-	reqCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
-	defer cancel()
-	req, err := http.NewRequestWithContext(reqCtx, http.MethodPost, baseURL+"/reminders/newreminder", strings.NewReader(`{"dueTime": "0","period": "2m"}`))
-	require.NoError(t, err)
-	req.Header.Set("Content-Type", "application/json")
-	resp, err := client.Do(req)
-	require.NoError(t, err)
-	require.NoError(t, resp.Body.Close())
-	require.Equal(t, http.StatusNoContent, resp.StatusCode)
-}
-
-func loadRemindersFromDB(t *testing.T, ctx context.Context, db *sqlite.SQLite) (storedVal string) {
-	queryCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
-	defer cancel()
-	err := db.GetConnection(t).QueryRowContext(queryCtx, fmt.Sprintf("SELECT value FROM %s WHERE key = 'actors||myactortype'", db.TableName())).Scan(&storedVal)
-	require.NoError(t, err)
-	return storedVal
-}
-
-type httpServer struct {
-	actorsReady          atomic.Bool
-	actorsReadyCh        chan struct{}
-	remindersInvokeCount atomic.Uint32
-}
-
-func (h *httpServer) NewHandler() http.Handler {
-	h.actorsReadyCh = make(chan struct{})
-
-	r := chi.NewRouter()
-	r.Get("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	r.Get("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		if h.actorsReady.CompareAndSwap(false, true) {
-			close(h.actorsReadyCh)
-		}
-		w.WriteHeader(http.StatusOK)
-	})
-	r.HandleFunc("/actors/myactortype/myactorid", func(w http.ResponseWriter, r *http.Request) {})
-	r.HandleFunc("/actors/myactortype/myactorid/method/foo", func(w http.ResponseWriter, r *http.Request) {})
-	r.HandleFunc("/actors/myactortype/myactorid/method/remind/newreminder", func(w http.ResponseWriter, r *http.Request) {
-		h.remindersInvokeCount.Add(1)
-	})
-	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`OK`))
-	})
-	return r
-}
-
-func (h *httpServer) WaitForActorsReady(ctx context.Context) error {
-	select {
-	case <-ctx.Done():
-		return ctx.Err()
-	case <-h.actorsReadyCh:
-		return nil
-	}
-}
diff --git a/tests/integration/suite/actors/reminders/serialization/default.go b/tests/integration/suite/actors/reminders/serialization/default.go
deleted file mode 100644
index 2f61a8b0e..000000000
--- a/tests/integration/suite/actors/reminders/serialization/default.go
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package serialization
-
-import (
-	"context"
-	"fmt"
-	"runtime"
-	"strconv"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(defaultS))
-}
-
-// defaultS ensures that reminders are stored as JSON by default.
-type defaultS struct {
-	daprd   *daprd.Daprd
-	srv     *prochttp.HTTP
-	handler *httpServer
-	place   *placement.Placement
-	db      *sqlite.SQLite
-}
-
-func (d *defaultS) Setup(t *testing.T) []framework.Option {
-	if runtime.GOOS == "windows" {
-		t.Skip("Skipping test on Windows due to SQLite limitations")
-	}
-
-	d.place = placement.New(t)
-
-	d.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-
-	d.handler = new(httpServer)
-	d.srv = prochttp.New(t, prochttp.WithHandler(d.handler.NewHandler()))
-	d.daprd = daprd.New(t,
-		daprd.WithResourceFiles(d.db.GetComponent(t)),
-		daprd.WithPlacementAddresses("127.0.0.1:"+strconv.Itoa(d.place.Port())),
-		daprd.WithAppPort(d.srv.Port()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`),
-		daprd.WithAppHealthCheck(true),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(d.db, d.place, d.srv, d.daprd),
-	}
-}
-
-func (d *defaultS) Run(t *testing.T, ctx context.Context) {
-	d.place.WaitUntilRunning(t, ctx)
-	d.daprd.WaitUntilRunning(t, ctx)
-	require.NoError(t, d.handler.WaitForActorsReady(ctx))
-
-	client := client.HTTP(t)
-	baseURL := fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/myactorid", d.daprd.HTTPPort())
-
-	invokeActor(t, ctx, baseURL, client)
-
-	storeReminder(t, ctx, baseURL, client)
-
-	// Check the data in the SQLite database
-	// The value must begin with `[{`, which indicates it was serialized as JSON
-	storedVal := loadRemindersFromDB(t, ctx, d.db)
-	assert.Truef(t, strings.HasPrefix(storedVal, "[{"), "Prefix not found in value: '%v'", storedVal)
-
-	assert.Eventually(t, func() bool {
-		return d.handler.remindersInvokeCount.Load() > 0
-	}, 5*time.Second, 10*time.Millisecond, "Reminder was not invoked at least once")
-}
diff --git a/tests/integration/suite/actors/reminders/serialization/json.go b/tests/integration/suite/actors/reminders/serialization/json.go
deleted file mode 100644
index 97adb3aae..000000000
--- a/tests/integration/suite/actors/reminders/serialization/json.go
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package serialization
-
-import (
-	"context"
-	"fmt"
-	"runtime"
-	"strconv"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(jsonFormat))
-}
-
-// jsonFormat tests:
-// - That reminders are serialized to JSON when the Actors API level in the cluster is < 20
-type jsonFormat struct {
-	daprd   *daprd.Daprd
-	srv     *prochttp.HTTP
-	handler *httpServer
-	place   *placement.Placement
-	db      *sqlite.SQLite
-}
-
-func (j *jsonFormat) Setup(t *testing.T) []framework.Option {
-	if runtime.GOOS == "windows" {
-		t.Skip("Skipping test on Windows due to SQLite limitations")
-	}
-
-	// Init placement with a maximum API level of 10
-	// We need to set the max API level to 10, because levels 20 and up with serialise as protobuf
-	j.place = placement.New(t,
-		placement.WithMaxAPILevel(10),
-	)
-
-	// Create a SQLite database
-	j.db = sqlite.New(t, sqlite.WithActorStateStore(true))
-
-	// Init daprd and the HTTP server
-	j.handler = &httpServer{}
-	j.srv = prochttp.New(t, prochttp.WithHandler(j.handler.NewHandler()))
-	j.daprd = daprd.New(t,
-		daprd.WithResourceFiles(j.db.GetComponent(t)),
-		daprd.WithPlacementAddresses("127.0.0.1:"+strconv.Itoa(j.place.Port())),
-		daprd.WithAppPort(j.srv.Port()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`),
-		daprd.WithAppHealthCheck(true),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(j.db, j.place, j.srv, j.daprd),
-	}
-}
-
-func (j *jsonFormat) Run(t *testing.T, ctx context.Context) {
-	// Wait for placement to be ready
-	j.place.WaitUntilRunning(t, ctx)
-
-	// Wait for daprd to be ready
-	j.daprd.WaitUntilRunning(t, ctx)
-
-	// Wait for actors to be ready
-	err := j.handler.WaitForActorsReady(ctx)
-	require.NoError(t, err)
-
-	client := client.HTTP(t)
-	baseURL := fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/myactorid", j.daprd.HTTPPort())
-
-	// Invoke an actor to confirm everything is ready to go
-	invokeActor(t, ctx, baseURL, client)
-
-	// Store a reminder
-	// This causes the data in the state store to be updated
-	storeReminder(t, ctx, baseURL, client)
-
-	// Check the data in the SQLite database
-	// The value must begin with `[{`, which indicates it was serialized as JSON
-	storedVal := loadRemindersFromDB(t, ctx, j.db)
-	assert.Truef(t, strings.HasPrefix(storedVal, "[{"), "Prefix not found in value: '%v'", storedVal)
-
-	// Ensure the reminder was invoked at least once
-	assert.Eventually(t, func() bool {
-		return j.handler.remindersInvokeCount.Load() > 0
-	}, 5*time.Second, 10*time.Millisecond, "Reminder was not invoked at least once")
-}
diff --git a/tests/integration/suite/actors/reminders/serialization/protobuf.go b/tests/integration/suite/actors/reminders/serialization/protobuf.go
deleted file mode 100644
index 9081ca4ec..000000000
--- a/tests/integration/suite/actors/reminders/serialization/protobuf.go
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
-Copyright 2023 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package serialization
-
-import (
-	"bytes"
-	"context"
-	"encoding/base64"
-	"fmt"
-	"runtime"
-	"strconv"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/client"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	"github.com/dapr/dapr/tests/integration/framework/process/sqlite"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(protobufFormat))
-}
-
-// protobufFormat tests:
-// - The ability for daprd to read reminders serialized as JSON and protobuf
-// - That reminders are serialized to protobuf when the Actors API level in the cluster is >= 20
-type protobufFormat struct {
-	daprd   *daprd.Daprd
-	srv     *prochttp.HTTP
-	handler *httpServer
-	place   *placement.Placement
-	db      *sqlite.SQLite
-}
-
-func (p *protobufFormat) Setup(t *testing.T) []framework.Option {
-	if runtime.GOOS == "windows" {
-		t.Skip("Skipping test on Windows due to SQLite limitations")
-	}
-
-	// Init placement with minimum API level of 20
-	p.place = placement.New(t, placement.WithMaxAPILevel(-1), placement.WithMinAPILevel(20))
-
-	// Create a SQLite database and ensure state tables exist
-	now := time.Now().UTC().Format(time.RFC3339)
-	p.db = sqlite.New(t,
-		sqlite.WithActorStateStore(true),
-		sqlite.WithCreateStateTables(),
-		sqlite.WithTableName("state"),
-		sqlite.WithExecs(fmt.Sprintf(`
-INSERT INTO state VALUES
-  ('actors||myactortype','[{"registeredTime":"%[1]s","period":"2m","actorID":"myactorid","actorType":"myactortype","name":"oldreminder","dueTime":"0"}]',0,'e467f810-4e93-45ed-85d9-e68d9fc7af4a',NULL,'%[1]s'),
-  ('actors||myactortype||metadata','{"id":"00000000-0000-0000-0000-000000000000","actorRemindersMetadata":{"partitionCount":0}}',0,'e82c5496-ae32-40a6-9578-6a7bd84ff331',NULL,'%[1]s');
-`, now)),
-	)
-
-	// Init daprd and the HTTP server
-	p.handler = &httpServer{}
-	p.srv = prochttp.New(t, prochttp.WithHandler(p.handler.NewHandler()))
-	p.daprd = daprd.New(t,
-		daprd.WithResourceFiles(p.db.GetComponent(t)),
-		daprd.WithPlacementAddresses("127.0.0.1:"+strconv.Itoa(p.place.Port())),
-		daprd.WithAppPort(p.srv.Port()),
-		daprd.WithConfigManifests(t, `
-apiVersion: dapr.io/v1alpha1
-kind: Configuration
-metadata:
-  name: schedulerreminders
-spec:
-  features:
-  - name: SchedulerReminders
-    enabled: false
-`),
-		daprd.WithAppHealthCheck(true),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(p.db, p.place, p.srv, p.daprd),
-	}
-}
-
-func (p *protobufFormat) Run(t *testing.T, ctx context.Context) {
-	// Wait for placement to be ready
-	p.place.WaitUntilRunning(t, ctx)
-
-	// Wait for daprd to be ready
-	p.daprd.WaitUntilRunning(t, ctx)
-
-	// Wait for actors to be ready
-	err := p.handler.WaitForActorsReady(ctx)
-	require.NoError(t, err)
-
-	client := client.HTTP(t)
-	baseURL := fmt.Sprintf("http://localhost:%d/v1.0/actors/myactortype/myactorid", p.daprd.HTTPPort())
-
-	// Invoke an actor to confirm everything is ready to go
-	invokeActor(t, ctx, baseURL, client)
-
-	// Store a reminder (which has the same name as the one already in the state store)
-	// This causes the data in the state store to be updated
-	storeReminder(t, ctx, baseURL, client)
-
-	// Check the data in the SQLite database
-	// The value must be base64-encoded, and after being decoded it should begin with `\0pb`, which indicates it was serialized as protobuf
-	storedVal := loadRemindersFromDB(t, ctx, p.db)
-	storedValBytes, err := base64.StdEncoding.DecodeString(storedVal)
-	require.NoErrorf(t, err, "Failed to decode value from base64: '%v'", storedVal)
-	assert.Truef(t, bytes.HasPrefix(storedValBytes, []byte{0, 'p', 'b'}), "Prefix not found in value: '%v'", storedVal)
-}
diff --git a/tests/integration/suite/actors/reminders/store.go b/tests/integration/suite/actors/reminders/store.go
deleted file mode 100644
index 301871ad1..000000000
--- a/tests/integration/suite/actors/reminders/store.go
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-Copyright 2024 The Dapr Authors
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-    http://www.apache.org/licenses/LICENSE-2.0
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package reminders
-
-import (
-	"context"
-	"net/http"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-
-	rtv1 "github.com/dapr/dapr/pkg/proto/runtime/v1"
-	"github.com/dapr/dapr/tests/integration/framework"
-	"github.com/dapr/dapr/tests/integration/framework/process/daprd"
-	prochttp "github.com/dapr/dapr/tests/integration/framework/process/http"
-	"github.com/dapr/dapr/tests/integration/framework/process/placement"
-	procscheduler "github.com/dapr/dapr/tests/integration/framework/process/scheduler"
-	"github.com/dapr/dapr/tests/integration/suite"
-)
-
-func init() {
-	suite.Register(new(store))
-}
-
-type store struct {
-	daprd     *daprd.Daprd
-	place     *placement.Placement
-	scheduler *procscheduler.Scheduler
-}
-
-func (s *store) Setup(t *testing.T) []framework.Option {
-	handler := http.NewServeMux()
-	handler.HandleFunc("/dapr/config", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(`{"entities": ["myactortype"]}`))
-	})
-	handler.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
-		w.WriteHeader(http.StatusOK)
-	})
-
-	s.scheduler = procscheduler.New(t)
-	srv := prochttp.New(t, prochttp.WithHandler(handler))
-	s.place = placement.New(t)
-	s.daprd = daprd.New(t,
-		daprd.WithInMemoryActorStateStore("mystore"),
-		daprd.WithPlacementAddresses(s.place.Address()),
-		daprd.WithSchedulerAddresses(s.scheduler.Address()),
-		daprd.WithAppPort(srv.Port()),
-	)
-
-	return []framework.Option{
-		framework.WithProcesses(s.scheduler, s.place, srv, s.daprd),
-	}
-}
-
-func (s *store) Run(t *testing.T, ctx context.Context) {
-	s.daprd.WaitUntilRunning(t, ctx)
-
-	_, err := s.daprd.GRPCClient(t, ctx).RegisterActorReminder(ctx, &rtv1.RegisterActorReminderRequest{
-		ActorType: "myactortype",
-		ActorId:   "myactorid",
-		Name:      "remindermethod",
-		DueTime:   "100s",
-		Data:      []byte("reminderdata"),
-	})
-	require.NoError(t, err)
-
-	assert.Len(t, s.scheduler.EtcdJobs(t, ctx), 1)
-}
