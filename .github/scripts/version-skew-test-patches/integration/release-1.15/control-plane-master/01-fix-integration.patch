diff --git a/Makefile b/Makefile
index 05eb332d8..9381202b4 100644
--- a/Makefile
+++ b/Makefile
@@ -385,7 +385,7 @@ test-integration: test-deps
 			--jsonfile $(TEST_OUTPUT_FILE_PREFIX)_integration.json \
 			--format testname \
 			-- \
-			./tests/integration -timeout=20m -count=1 -v -tags="integration$(TEST_ADDITIONAL_TAGS)" -integration-parallel=false
+			./tests/integration -timeout=40m -count=1 -v -tags="integration$(TEST_ADDITIONAL_TAGS)" -integration-parallel=false
 
 .PHONY: test-integration-parallel
 test-integration-parallel: test-deps
@@ -393,7 +393,7 @@ test-integration-parallel: test-deps
 			--jsonfile $(TEST_OUTPUT_FILE_PREFIX)_integration.json \
 			--format testname \
 			-- \
-			./tests/integration -timeout=20m -count=1 -v -tags="integration$(TEST_ADDITIONAL_TAGS)" -integration-parallel=true
+			./tests/integration -timeout=40m -count=1 -v -tags="integration$(TEST_ADDITIONAL_TAGS)" -integration-parallel=true
 
 ################################################################################
 # Target: lint                                                                 #
@@ -402,7 +402,7 @@ test-integration-parallel: test-deps
 # You can download version v1.64.6 at https://github.com/golangci/golangci-lint/releases/tag/v1.64.6
 .PHONY: lint
 lint: check-linter
-	$(GOLANGCI_LINT) run --build-tags=$(GOLANGCI_LINT_TAGS) --timeout=20m
+	$(GOLANGCI_LINT) run --build-tags=$(GOLANGCI_LINT_TAGS) --timeout=40m
 
 
 ################################################################################
diff --git a/tests/integration/framework/metrics/withlabels.go b/tests/integration/framework/metrics/withlabels.go
new file mode 100644
index 000000000..2b8cc8d43
--- /dev/null
+++ b/tests/integration/framework/metrics/withlabels.go
@@ -0,0 +1,112 @@
+/*
+Copyright 2025 The Dapr Authors
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package metrics
+
+import (
+	"context"
+	"fmt"
+	"net/http"
+	"strings"
+	"testing"
+
+	dto "github.com/prometheus/client_model/go"
+	"github.com/prometheus/common/expfmt"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+
+	"github.com/dapr/dapr/tests/integration/framework/client"
+)
+
+type MetricsWithLabels struct {
+	Metrics map[string]map[string]float64
+}
+
+func NewWithLabels(t *testing.T, ctx context.Context, url string) *MetricsWithLabels {
+	t.Helper()
+
+	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
+	require.NoError(t, err)
+
+	httpclient := client.HTTP(t)
+	resp, err := httpclient.Do(req)
+	require.NoError(t, err)
+	defer resp.Body.Close()
+
+	assert.Equal(t, http.StatusOK, resp.StatusCode)
+
+	parser := expfmt.TextParser{}
+	metricFamilies, err := parser.TextToMetricFamilies(resp.Body)
+	require.NoError(t, err)
+
+	result := &MetricsWithLabels{
+		Metrics: make(map[string]map[string]float64),
+	}
+
+	for name, mf := range metricFamilies {
+		if _, ok := result.Metrics[name]; !ok {
+			result.Metrics[name] = make(map[string]float64)
+		}
+
+		for _, m := range mf.GetMetric() {
+			keys := make([]string, 0, len(m.GetLabel()))
+			for _, lp := range m.GetLabel() {
+				keys = append(keys, lp.GetName()+"="+lp.GetValue())
+			}
+			baseLabelKey := strings.Join(keys, ",")
+
+			switch mf.GetType() {
+			case dto.MetricType_COUNTER:
+				result.Metrics[name][baseLabelKey] = m.GetCounter().GetValue()
+
+			case dto.MetricType_GAUGE:
+				result.Metrics[name][baseLabelKey] = m.GetGauge().GetValue()
+
+			case dto.MetricType_HISTOGRAM:
+				hist := m.GetHistogram()
+				// Add sum
+				sumName := name + "_sum"
+				if _, ok := result.Metrics[sumName]; !ok {
+					result.Metrics[sumName] = make(map[string]float64)
+				}
+				result.Metrics[sumName][baseLabelKey] = hist.GetSampleSum()
+
+				// Add count
+				countName := name + "_count"
+				if _, ok := result.Metrics[countName]; !ok {
+					result.Metrics[countName] = make(map[string]float64)
+				}
+				result.Metrics[countName][baseLabelKey] = float64(hist.GetSampleCount())
+
+				// Add each bucket as its own labeled metric
+				bucketName := name + "_bucket"
+				if _, ok := result.Metrics[bucketName]; !ok {
+					result.Metrics[bucketName] = make(map[string]float64)
+				}
+				for _, b := range hist.GetBucket() {
+					bucketKey := baseLabelKey
+					if bucketKey != "" {
+						bucketKey += ","
+					}
+					bucketKey += fmt.Sprintf(`le=%f`, b.GetUpperBound())
+					result.Metrics[bucketName][bucketKey] = float64(b.GetCumulativeCount())
+				}
+
+			default:
+				continue
+			}
+		}
+	}
+
+	return result
+}
diff --git a/tests/integration/framework/process/exec/exec.go b/tests/integration/framework/process/exec/exec.go
index a8cfe3c0e..7e1bc21ae 100644
--- a/tests/integration/framework/process/exec/exec.go
+++ b/tests/integration/framework/process/exec/exec.go
@@ -70,6 +70,9 @@ func New(t *testing.T, binPath string, args []string, fopts ...Option) *exec {
 			}
 		},
 		exitCode: defaultExitCode,
+		envs: map[string]string{
+			"DAPR_UNSAFE_SKIP_CONTAINER_UID_GID_CHECK": "true",
+		},
 	}
 
 	for _, fopt := range fopts {
diff --git a/tests/integration/framework/process/scheduler/scheduler.go b/tests/integration/framework/process/scheduler/scheduler.go
index b4f8d18c6..54fcfb237 100644
--- a/tests/integration/framework/process/scheduler/scheduler.go
+++ b/tests/integration/framework/process/scheduler/scheduler.go
@@ -497,3 +497,7 @@ func (s *Scheduler) ListAllKeys(t *testing.T, ctx context.Context, prefix string
 
 	return resp
 }
+
+func (s *Scheduler) MetricsWithLabels(t *testing.T, ctx context.Context) *metrics.MetricsWithLabels {
+	return metrics.NewWithLabels(t, ctx, fmt.Sprintf("http://%s/metrics", s.MetricsAddress()))
+}
diff --git a/tests/integration/framework/process/sentry/options.go b/tests/integration/framework/process/sentry/options.go
index 02e90bb69..2001dc2a9 100644
--- a/tests/integration/framework/process/sentry/options.go
+++ b/tests/integration/framework/process/sentry/options.go
@@ -32,6 +32,7 @@ type options struct {
 	kubeconfig    *string
 	trustDomain   *string
 	namespace     *string
+	mode          *string
 }
 
 // Option is a function that configures the process.
@@ -102,3 +103,9 @@ func WithNamespace(namespace string) Option {
 		o.namespace = &namespace
 	}
 }
+
+func WithMode(mode string) Option {
+	return func(o *options) {
+		o.mode = &mode
+	}
+}
diff --git a/tests/integration/framework/process/sentry/sentry.go b/tests/integration/framework/process/sentry/sentry.go
index d733c8bb9..937b14d1b 100644
--- a/tests/integration/framework/process/sentry/sentry.go
+++ b/tests/integration/framework/process/sentry/sentry.go
@@ -129,6 +129,10 @@ func New(t *testing.T, fopts ...Option) *Sentry {
 		args = append(args, "-trust-domain="+*opts.trustDomain)
 	}
 
+	if opts.mode != nil {
+		args = append(args, "-mode="+*opts.mode)
+	}
+
 	if opts.writeConfig {
 		configPath := filepath.Join(t.TempDir(), "sentry-config.yaml")
 		require.NoError(t, os.WriteFile(configPath, []byte(opts.configuration), 0o600))
diff --git a/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go b/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go
index e115dad59..b718bed24 100644
--- a/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go
+++ b/tests/integration/suite/actors/reminders/migration/scheduler/overwrite.go
@@ -198,6 +198,8 @@ spec:
 	}, njob.GetJob())
 	daprd2.Cleanup(t)
 
+	t.Skip("Jobs cannot be upsert without override flag")
+
 	daprd3.Run(t, ctx)
 	daprd3.WaitUntilRunning(t, ctx)
 	resp, err = sclient.ListJobs(ctx, &schedulerv1.ListJobsRequest{
diff --git a/tests/integration/suite/actors/reminders/scheduler/upsert.go b/tests/integration/suite/actors/reminders/scheduler/upsert.go
index 0ff523ad0..3fee2f30d 100644
--- a/tests/integration/suite/actors/reminders/scheduler/upsert.go
+++ b/tests/integration/suite/actors/reminders/scheduler/upsert.go
@@ -47,6 +47,8 @@ type upsert struct {
 }
 
 func (u *upsert) Setup(t *testing.T) []framework.Option {
+	t.Skip("Jobs can no longer be upserted without an override flag set")
+
 	configFile := filepath.Join(t.TempDir(), "config.yaml")
 	require.NoError(t, os.WriteFile(configFile, []byte(`
 apiVersion: dapr.io/v1alpha1
diff --git a/tests/integration/suite/daprd/jobs/grpc/basic.go b/tests/integration/suite/daprd/jobs/grpc/basic.go
index 3a61c6fa9..601bbb2c7 100644
--- a/tests/integration/suite/daprd/jobs/grpc/basic.go
+++ b/tests/integration/suite/daprd/jobs/grpc/basic.go
@@ -17,6 +17,7 @@ import (
 	"context"
 	"testing"
 
+	"github.com/google/uuid"
 	"github.com/stretchr/testify/require"
 	"google.golang.org/protobuf/types/known/anypb"
 
@@ -66,13 +67,13 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 			},
 			{
 				Job: &rtv1.Job{
-					Name:     "test",
+					Name:     "test" + uuid.NewString(),
 					Schedule: nil,
 				},
 			},
 			{
 				Job: &rtv1.Job{
-					Name: "test",
+					Name: "test" + uuid.NewString(),
 					Ttl:  ptr.Of("3h"),
 				},
 			},
@@ -86,14 +87,14 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 		for _, req := range []*rtv1.ScheduleJobRequest{
 			{
 				Job: &rtv1.Job{
-					Name:     "test",
+					Name:     "test" + uuid.NewString(),
 					Schedule: ptr.Of("@daily"),
 					Repeats:  ptr.Of(uint32(1)),
 				},
 			},
 			{
 				Job: &rtv1.Job{
-					Name:     "test1",
+					Name:     "test1" + uuid.NewString(),
 					Schedule: ptr.Of("@daily"),
 					Data: &anypb.Any{
 						Value: []byte("test"),
@@ -103,7 +104,7 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 			},
 			{
 				Job: &rtv1.Job{
-					Name:     "test1",
+					Name:     "test1" + uuid.NewString(),
 					Schedule: ptr.Of("@daily"),
 					Data: &anypb.Any{
 						Value: []byte("test"),
diff --git a/tests/integration/suite/daprd/jobs/http/basic.go b/tests/integration/suite/daprd/jobs/http/basic.go
index d9385d11e..219549200 100644
--- a/tests/integration/suite/daprd/jobs/http/basic.go
+++ b/tests/integration/suite/daprd/jobs/http/basic.go
@@ -21,6 +21,7 @@ import (
 	"strings"
 	"testing"
 
+	"github.com/google/uuid"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 
@@ -56,8 +57,6 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 	b.scheduler.WaitUntilRunning(t, ctx)
 	b.daprd.WaitUntilRunning(t, ctx)
 
-	postURL := fmt.Sprintf("http://localhost:%d/v1.0-alpha1/jobs/test", b.daprd.HTTPPort())
-
 	httpClient := client.HTTP(t)
 
 	t.Run("bad json", func(t *testing.T) {
@@ -69,6 +68,8 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 			`{"name": "test"}`,
 			`{"schedule": "test", "repeats": -1}`,
 		} {
+			postURL := fmt.Sprintf("http://localhost:%d/v1.0-alpha1/jobs/test-%s", b.daprd.HTTPPort(), uuid.NewString())
+
 			req, err := http.NewRequestWithContext(ctx, http.MethodPost, postURL, strings.NewReader(body))
 			require.NoError(t, err)
 			resp, err := httpClient.Do(req)
@@ -87,6 +88,8 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 			`{"schedule": "@daily", "repeats": 3, "due_time": "10s", "ttl": "11s", "data": "{\"@type\": \"type.googleapis.com/google.protobuf.StringValue\", \"value\": \"Hello, World!\"}"}`,
 			`{"schedule": "@daily", "repeats": 3, "due_time": "10s", "ttl": "11s", "data": "Hello, World!"}`,
 		} {
+			postURL := fmt.Sprintf("http://localhost:%d/v1.0-alpha1/jobs/test-%s", b.daprd.HTTPPort(), uuid.NewString())
+
 			req, err := http.NewRequestWithContext(ctx, http.MethodPost, postURL, strings.NewReader(body))
 			require.NoError(t, err)
 			resp, err := httpClient.Do(req)
diff --git a/tests/integration/suite/daprd/metadata/base.go b/tests/integration/suite/daprd/metadata/base.go
index 4a0955eff..c8f76245e 100644
--- a/tests/integration/suite/daprd/metadata/base.go
+++ b/tests/integration/suite/daprd/metadata/base.go
@@ -106,11 +106,11 @@ func validateResponse(t *testing.T, appID string, appPort int, body io.Reader) {
 	require.NoError(t, err)
 
 	require.Equal(t, appID, bodyMap["id"])
-	require.Equal(t, "edge", bodyMap["runtimeVersion"])
+	require.Equal(t, "1.15.9", bodyMap["runtimeVersion"])
 
 	extended, ok := bodyMap["extended"].(map[string]interface{})
 	require.True(t, ok)
-	require.Equal(t, "edge", extended["daprRuntimeVersion"])
+	require.Equal(t, "1.15.9", extended["daprRuntimeVersion"])
 
 	appConnectionProperties, ok := bodyMap["appConnectionProperties"].(map[string]interface{})
 	require.True(t, ok)
diff --git a/tests/integration/suite/operator/api/listcomponents/basic.go b/tests/integration/suite/operator/api/listcomponents/basic.go
index 12c16bc6d..e1d84ae29 100644
--- a/tests/integration/suite/operator/api/listcomponents/basic.go
+++ b/tests/integration/suite/operator/api/listcomponents/basic.go
@@ -131,6 +131,7 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 		b2, err := json.Marshal(b.comp2)
 		require.NoError(t, err)
 
+		require.Len(t, resp.GetComponents(), 2)
 		if strings.Contains(string(resp.GetComponents()[0]), "mycomponent") {
 			assert.JSONEq(t, string(b1), string(resp.GetComponents()[0]))
 			assert.JSONEq(t, string(b2), string(resp.GetComponents()[1]))
diff --git a/tests/integration/suite/operator/api/listcomponents/scopes/addapp.go b/tests/integration/suite/operator/api/listcomponents/scopes/addapp.go
index ecf11b558..b01f3c4ba 100644
--- a/tests/integration/suite/operator/api/listcomponents/scopes/addapp.go
+++ b/tests/integration/suite/operator/api/listcomponents/scopes/addapp.go
@@ -104,6 +104,7 @@ func (a *addapp) Run(t *testing.T, ctx context.Context) {
 		}
 	}, time.Second*10, time.Millisecond*10)
 
+	require.Len(t, list.GetComponents(), 1)
 	var gotComp compapi.Component
 	require.NoError(t, json.Unmarshal(list.GetComponents()[0], &gotComp))
 	assert.Equal(t, comp, &gotComp)
diff --git a/tests/integration/suite/operator/api/listcomponents/scopes/deleteapp.go b/tests/integration/suite/operator/api/listcomponents/scopes/deleteapp.go
index 4687e7f30..a90a58db6 100644
--- a/tests/integration/suite/operator/api/listcomponents/scopes/deleteapp.go
+++ b/tests/integration/suite/operator/api/listcomponents/scopes/deleteapp.go
@@ -104,6 +104,7 @@ func (d *deleteapp) Run(t *testing.T, ctx context.Context) {
 		}
 	}, time.Second*10, time.Millisecond*10)
 
+	require.Len(t, list.GetComponents(), 1)
 	var gotComp compapi.Component
 	require.NoError(t, json.Unmarshal(list.GetComponents()[0], &gotComp))
 	assert.Equal(t, comp, &gotComp)
diff --git a/tests/integration/suite/scheduler/authz/mtls.go b/tests/integration/suite/scheduler/authz/mtls.go
index 053555d44..70346bc59 100644
--- a/tests/integration/suite/scheduler/authz/mtls.go
+++ b/tests/integration/suite/scheduler/authz/mtls.go
@@ -17,6 +17,7 @@ import (
 	"context"
 	"testing"
 
+	"github.com/google/uuid"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 	"google.golang.org/grpc/codes"
@@ -59,7 +60,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 	client := m.scheduler.ClientMTLS(t, ctx, "foo")
 
 	req := &schedulerv1pb.ScheduleJobRequest{
-		Name: "testJob",
+		Name: "testJob-" + uuid.NewString(),
 		Job: &schedulerv1pb.Job{
 			Schedule: ptr.Of("@daily"),
 		},
@@ -85,7 +86,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 		"ScheduleJob": {
 			funcGoodAppID: func() error {
 				_, err := client.ScheduleJob(ctx, &schedulerv1pb.ScheduleJobRequest{
-					Name: "testJob",
+					Name: "testJob-" + uuid.NewString(),
 					Job:  &schedulerv1pb.Job{Schedule: ptr.Of("@daily")},
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "foo",
@@ -99,7 +100,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 			},
 			funcBadAppID: func() error {
 				_, err := client.ScheduleJob(ctx, &schedulerv1pb.ScheduleJobRequest{
-					Name: "testJob",
+					Name: "testJob-" + uuid.NewString(),
 					Job:  &schedulerv1pb.Job{Schedule: ptr.Of("@daily")},
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "not-foo",
@@ -115,7 +116,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 		"GetJob": {
 			funcGoodAppID: func() error {
 				_, err := client.GetJob(ctx, &schedulerv1pb.GetJobRequest{
-					Name: "testJob",
+					Name: req.GetName(),
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "foo",
 						Namespace: "default",
@@ -128,7 +129,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 			},
 			funcBadAppID: func() error {
 				_, err := client.GetJob(ctx, &schedulerv1pb.GetJobRequest{
-					Name: "testJob",
+					Name: req.GetName(),
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "not-foo",
 						Namespace: "default",
@@ -143,7 +144,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 		"DeleteJob": {
 			funcGoodAppID: func() error {
 				_, err := client.DeleteJob(ctx, &schedulerv1pb.DeleteJobRequest{
-					Name: "testJob",
+					Name: req.GetName(),
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "foo",
 						Namespace: "default",
@@ -156,7 +157,7 @@ func (m *mtls) Run(t *testing.T, ctx context.Context) {
 			},
 			funcBadAppID: func() error {
 				_, err := client.DeleteJob(ctx, &schedulerv1pb.DeleteJobRequest{
-					Name: "testJob",
+					Name: req.GetName(),
 					Metadata: &schedulerv1pb.JobMetadata{
 						AppId:     "not-foo",
 						Namespace: "default",
diff --git a/tests/integration/suite/scheduler/metrics/actors.go b/tests/integration/suite/scheduler/metrics/actors.go
index 69f9b80ec..d12168d76 100644
--- a/tests/integration/suite/scheduler/metrics/actors.go
+++ b/tests/integration/suite/scheduler/metrics/actors.go
@@ -106,8 +106,8 @@ func (a *actors) Run(t *testing.T, ctx context.Context) {
 	require.NoError(t, err)
 
 	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-		metrics = a.scheduler.Metrics(c, ctx).All()
-		assert.Equal(c, 1, int(metrics["dapr_scheduler_jobs_created_total"]))
+		m := a.scheduler.MetricsWithLabels(t, ctx)
+		assert.Equal(c, 1, int(m.Metrics["dapr_scheduler_jobs_created_total"]["type=actor"]))
 	}, time.Second*4, 10*time.Millisecond)
 
 	assert.EventuallyWithT(t, func(c *assert.CollectT) {
diff --git a/tests/integration/suite/scheduler/metrics/basic.go b/tests/integration/suite/scheduler/metrics/basic.go
index 130cd15ca..6c406ff45 100644
--- a/tests/integration/suite/scheduler/metrics/basic.go
+++ b/tests/integration/suite/scheduler/metrics/basic.go
@@ -97,8 +97,8 @@ func (b *basic) Run(t *testing.T, ctx context.Context) {
 			require.NoError(t, err)
 
 			assert.EventuallyWithT(t, func(c *assert.CollectT) {
-				metrics := b.scheduler.Metrics(c, ctx).All()
-				assert.Equal(c, i, int(metrics["dapr_scheduler_jobs_created_total"]))
+				metrics := b.scheduler.MetricsWithLabels(t, ctx)
+				assert.Equal(c, i, int(metrics.Metrics["dapr_scheduler_jobs_created_total"]["type=job"]))
 			}, time.Second*3, time.Millisecond*10)
 		}
 	})
diff --git a/tests/integration/suite/scheduler/metrics/jobstriggered.go b/tests/integration/suite/scheduler/metrics/jobstriggered.go
index 4a3a6d8ea..d249ede77 100644
--- a/tests/integration/suite/scheduler/metrics/jobstriggered.go
+++ b/tests/integration/suite/scheduler/metrics/jobstriggered.go
@@ -138,7 +138,7 @@ func (j *jobstriggered) Run(t *testing.T, ctx context.Context) {
 	client := j.daprd.GRPCClient(t, ctx)
 	for name, test := range tests {
 		t.Run(name, func(t *testing.T) {
-			startTime := time.Now()
+			//startTime := time.Now()
 			_, err := client.ScheduleJobAlpha1(ctx, &runtimev1pb.ScheduleJobRequest{
 				Job: &runtimev1pb.Job{
 					Name:    name,
@@ -150,28 +150,33 @@ func (j *jobstriggered) Run(t *testing.T, ctx context.Context) {
 
 			select {
 			case job := <-j.jobChan:
-				receivedJobElapsed := time.Since(startTime).Milliseconds()
+				//receivedJobElapsed := time.Since(startTime).Milliseconds()
 				assert.NotNil(t, job)
 				assert.Equal(t, "job/"+name, job.GetMethod())
 				assert.Equal(t, commonv1pb.HTTPExtension_POST, job.GetHttpExtension().GetVerb())
 
 				assert.EventuallyWithT(t, func(c *assert.CollectT) {
-					metrics := j.scheduler.Metrics(c, ctx).All()
-					assert.Equal(c, int(j.jobstriggeredCount.Load()), int(metrics["dapr_scheduler_jobs_triggered_total"]))
-
-					// with duration metrics, the following metrics can be found:
-					// dapr_scheduler_trigger_duration_total_bucket
-					// dapr_scheduler_trigger_duration_total_sum
-					// dapr_scheduler_trigger_latency_count
-					avgTriggerLatency := metrics["dapr_scheduler_trigger_latency_sum"] / metrics["dapr_scheduler_trigger_latency_count"]
-					assert.Equal(c, int(j.jobstriggeredCount.Load()), int(metrics["dapr_scheduler_trigger_latency_count"]))
-
-					// ensure the trigger duration is less than 1 second (1000 milliseconds)
-					assert.Less(c, avgTriggerLatency, float64(1000), "Trigger duration should be less than 1 second")
-
-					grace := 1000
-					// triggered time should be less than the total round trip time of a job being scheduled and sent back to the app
-					assert.LessOrEqual(c, int64(avgTriggerLatency), receivedJobElapsed+int64(grace), "Trigger time should be less than the total elapsed time to receive the scheduled job")
+					metrics := j.scheduler.MetricsWithLabels(t, ctx)
+					total, ok := metrics.Metrics["dapr_scheduler_jobs_triggered_total"]
+					if !assert.True(c, ok) {
+						return
+					}
+					assert.Equal(c, int(j.jobstriggeredCount.Load()), int(total["type=job"]))
+
+					// Jobs metrics have been updated to include job type labels.
+					//// with duration metrics, the following metrics can be found:
+					//// dapr_scheduler_trigger_duration_total_bucket
+					//// dapr_scheduler_trigger_duration_total_sum
+					//// dapr_scheduler_trigger_latency_count
+					//avgTriggerLatency := metrics.Metrics["dapr_scheduler_trigger_latency_sum"] / metrics["dapr_scheduler_trigger_latency_count"]
+					//assert.Equal(c, int(j.jobstriggeredCount.Load()), int(metrics["dapr_scheduler_trigger_latency_count"]))
+
+					//// ensure the trigger duration is less than 1 second (1000 milliseconds)
+					//assert.Less(c, avgTriggerLatency, float64(1000), "Trigger duration should be less than 1 second")
+
+					//grace := 1000
+					//// triggered time should be less than the total round trip time of a job being scheduled and sent back to the app
+					//assert.LessOrEqual(c, int64(avgTriggerLatency), receivedJobElapsed+int64(grace), "Trigger time should be less than the total elapsed time to receive the scheduled job")
 				}, time.Second*3, 10*time.Millisecond)
 
 				test.exp(t, job)
diff --git a/tests/integration/suite/scheduler/scheduler.go b/tests/integration/suite/scheduler/scheduler.go
index 02e1e407f..65d4280ec 100644
--- a/tests/integration/suite/scheduler/scheduler.go
+++ b/tests/integration/suite/scheduler/scheduler.go
@@ -19,7 +19,6 @@ import (
 	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/failurepolicy"
 	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/helm"
 	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/kubernetes"
-	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/metrics"
 	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/quorum"
 	_ "github.com/dapr/dapr/tests/integration/suite/scheduler/staging"
 )
diff --git a/tests/integration/suite/sentry/utils/utils.go b/tests/integration/suite/sentry/utils/utils.go
new file mode 100644
index 000000000..f90602f22
--- /dev/null
+++ b/tests/integration/suite/sentry/utils/utils.go
@@ -0,0 +1,100 @@
+/*
+Copyright 2023 The Dapr Authors
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package utils
+
+import (
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+	authapi "k8s.io/api/authentication/v1"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	configapi "github.com/dapr/dapr/pkg/apis/configuration/v1alpha1"
+	"github.com/dapr/dapr/pkg/sentry/server/ca"
+	prockube "github.com/dapr/dapr/tests/integration/framework/process/kubernetes"
+)
+
+type KubeAPIOptions struct {
+	Bundle         ca.Bundle
+	Namespace      string
+	ServiceAccount string
+	AppID          string
+}
+
+func KubeAPI(t *testing.T, opts KubeAPIOptions) *prockube.Kubernetes {
+	t.Helper()
+
+	return prockube.New(t,
+		prockube.WithClusterDaprConfigurationList(t, new(configapi.ConfigurationList)),
+		prockube.WithDaprConfigurationGet(t, &configapi.Configuration{
+			TypeMeta:   metav1.TypeMeta{APIVersion: "dapr.io/v1alpha1", Kind: "Configuration"},
+			ObjectMeta: metav1.ObjectMeta{Namespace: "sentrynamespace", Name: "daprsystem"},
+			Spec: configapi.ConfigurationSpec{
+				MTLSSpec: &configapi.MTLSSpec{ControlPlaneTrustDomain: "integration.test.dapr.io"},
+			},
+		}),
+		prockube.WithSecretGet(t, &corev1.Secret{
+			TypeMeta:   metav1.TypeMeta{APIVersion: "v1", Kind: "Secret"},
+			ObjectMeta: metav1.ObjectMeta{Namespace: "sentrynamespace", Name: "dapr-trust-bundle"},
+			Data: map[string][]byte{
+				"ca.crt":     opts.Bundle.TrustAnchors,
+				"issuer.crt": opts.Bundle.IssChainPEM,
+				"issuer.key": opts.Bundle.IssKeyPEM,
+			},
+		}),
+		prockube.WithConfigMapGet(t, &corev1.ConfigMap{
+			TypeMeta:   metav1.TypeMeta{APIVersion: "v1", Kind: "ConfigMap"},
+			ObjectMeta: metav1.ObjectMeta{Namespace: "sentrynamespace", Name: "dapr-trust-bundle"},
+			Data:       map[string]string{"ca.crt": string(opts.Bundle.TrustAnchors)},
+		}),
+		prockube.WithClusterPodList(t, &corev1.PodList{
+			TypeMeta: metav1.TypeMeta{APIVersion: "v1", Kind: "PodList"},
+			Items: []corev1.Pod{
+				{
+					TypeMeta: metav1.TypeMeta{APIVersion: "v1", Kind: "Pod"},
+					ObjectMeta: metav1.ObjectMeta{
+						Namespace: opts.Namespace, Name: "mypod",
+						Annotations: map[string]string{"dapr.io/app-id": opts.AppID},
+					},
+					Spec: corev1.PodSpec{ServiceAccountName: opts.ServiceAccount},
+				},
+			},
+		}),
+		prockube.WithPath("/apis/authentication.k8s.io/v1/tokenreviews", func(w http.ResponseWriter, r *http.Request) {
+			assert.Equal(t, "POST", r.Method)
+			assert.Equal(t, "application/json", r.Header.Get("Content-Type"))
+			var request *authapi.TokenReview
+			assert.NoError(t, json.NewDecoder(r.Body).Decode(&request))
+			if !assert.Len(t, request.Spec.Audiences, 2) {
+				return
+			}
+			assert.Equal(t, "dapr.io/sentry", request.Spec.Audiences[0])
+			assert.Equal(t, "spiffe://integration.test.dapr.io/ns/sentrynamespace/dapr-sentry", request.Spec.Audiences[1])
+
+			resp, err := json.Marshal(&authapi.TokenReview{
+				Status: authapi.TokenReviewStatus{
+					Authenticated: true,
+					User:          authapi.UserInfo{Username: fmt.Sprintf("system:serviceaccount:%s:%s", opts.Namespace, opts.ServiceAccount)},
+				},
+			})
+			assert.NoError(t, err)
+			w.Header().Add("Content-Type", "application/json")
+			w.Write(resp)
+		}),
+	)
+}
diff --git a/tests/integration/suite/sentry/validator/kubernetes/kube.go b/tests/integration/suite/sentry/validator/kubernetes/kube.go
index 541da5e2f..717ae5181 100644
--- a/tests/integration/suite/sentry/validator/kubernetes/kube.go
+++ b/tests/integration/suite/sentry/validator/kubernetes/kube.go
@@ -26,12 +26,14 @@ import (
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 
+	"github.com/dapr/dapr/pkg/modes"
 	sentrypbv1 "github.com/dapr/dapr/pkg/proto/sentry/v1"
 	"github.com/dapr/dapr/pkg/sentry/server/ca"
 	"github.com/dapr/dapr/tests/integration/framework"
 	"github.com/dapr/dapr/tests/integration/framework/process/exec"
 	"github.com/dapr/dapr/tests/integration/framework/process/sentry"
 	"github.com/dapr/dapr/tests/integration/suite"
+	"github.com/dapr/dapr/tests/integration/suite/sentry/utils"
 	secpem "github.com/dapr/kit/crypto/pem"
 )
 
@@ -50,17 +52,18 @@ func (k *kube) Setup(t *testing.T) []framework.Option {
 	bundle, err := ca.GenerateBundle(rootKey, "integration.test.dapr.io", time.Second*5, nil)
 	require.NoError(t, err)
 
-	kubeAPI := kubeAPI(t, kubeAPIOptions{
-		bundle:         bundle,
-		namespace:      "mynamespace",
-		serviceAccount: "myserviceaccount",
-		appID:          "myappid",
+	kubeAPI := utils.KubeAPI(t, utils.KubeAPIOptions{
+		Bundle:         bundle,
+		Namespace:      "mynamespace",
+		ServiceAccount: "myserviceaccount",
+		AppID:          "myappid",
 	})
 
 	k.sentry = sentry.New(t,
 		sentry.WithWriteConfig(false),
 		sentry.WithKubeconfig(kubeAPI.KubeconfigPath(t)),
 		sentry.WithNamespace("sentrynamespace"),
+		sentry.WithMode(string(modes.KubernetesMode)),
 		sentry.WithExecOptions(
 			// Enable Kubernetes validator.
 			exec.WithEnvVars(t, "KUBERNETES_SERVICE_HOST", "anything"),
diff --git a/tests/integration/suite/sentry/validator/kubernetes/legacyid.go b/tests/integration/suite/sentry/validator/kubernetes/legacyid.go
index ad331b4ff..a39138f67 100644
--- a/tests/integration/suite/sentry/validator/kubernetes/legacyid.go
+++ b/tests/integration/suite/sentry/validator/kubernetes/legacyid.go
@@ -28,12 +28,14 @@ import (
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
 
+	"github.com/dapr/dapr/pkg/modes"
 	sentrypbv1 "github.com/dapr/dapr/pkg/proto/sentry/v1"
 	"github.com/dapr/dapr/pkg/sentry/server/ca"
 	"github.com/dapr/dapr/tests/integration/framework"
 	"github.com/dapr/dapr/tests/integration/framework/process/exec"
 	"github.com/dapr/dapr/tests/integration/framework/process/sentry"
 	"github.com/dapr/dapr/tests/integration/suite"
+	"github.com/dapr/dapr/tests/integration/suite/sentry/utils"
 )
 
 func init() {
@@ -52,16 +54,17 @@ func (l *legacyid) Setup(t *testing.T) []framework.Option {
 	bundle, err := ca.GenerateBundle(rootKey, "integration.test.dapr.io", time.Second*5, nil)
 	require.NoError(t, err)
 
-	kubeAPI := kubeAPI(t, kubeAPIOptions{
-		bundle:         bundle,
-		namespace:      "myns",
-		serviceAccount: "myaccount",
-		appID:          "myappid",
+	kubeAPI := utils.KubeAPI(t, utils.KubeAPIOptions{
+		Bundle:         bundle,
+		Namespace:      "myns",
+		ServiceAccount: "myaccount",
+		AppID:          "myappid",
 	})
 
 	l.sentry = sentry.New(t,
 		sentry.WithWriteConfig(false),
 		sentry.WithKubeconfig(kubeAPI.KubeconfigPath(t)),
+		sentry.WithMode(string(modes.KubernetesMode)),
 		sentry.WithExecOptions(
 			// Enable Kubernetes validator.
 			exec.WithEnvVars(t, "KUBERNETES_SERVICE_HOST", "anything"),
diff --git a/tests/integration/suite/sentry/validator/kubernetes/longname.go b/tests/integration/suite/sentry/validator/kubernetes/longname.go
index 59c3d997f..4f39f1896 100644
--- a/tests/integration/suite/sentry/validator/kubernetes/longname.go
+++ b/tests/integration/suite/sentry/validator/kubernetes/longname.go
@@ -29,6 +29,7 @@ import (
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
 
+	"github.com/dapr/dapr/pkg/modes"
 	sentrypbv1 "github.com/dapr/dapr/pkg/proto/sentry/v1"
 	"github.com/dapr/dapr/pkg/sentry/server/ca"
 	"github.com/dapr/dapr/tests/integration/framework"
@@ -36,6 +37,7 @@ import (
 	"github.com/dapr/dapr/tests/integration/framework/process/kubernetes"
 	"github.com/dapr/dapr/tests/integration/framework/process/sentry"
 	"github.com/dapr/dapr/tests/integration/suite"
+	"github.com/dapr/dapr/tests/integration/suite/sentry/utils"
 )
 
 func init() {
@@ -57,31 +59,32 @@ func (l *longname) Setup(t *testing.T) []framework.Option {
 	bundle, err := ca.GenerateBundle(rootKey, "integration.test.dapr.io", time.Second*5, nil)
 	require.NoError(t, err)
 
-	kubeAPI1 := kubeAPI(t, kubeAPIOptions{
-		bundle:         bundle,
-		namespace:      strings.Repeat("n", 253),
-		serviceAccount: strings.Repeat("s", 253),
-		appID:          "myapp",
+	kubeAPI1 := utils.KubeAPI(t, utils.KubeAPIOptions{
+		Bundle:         bundle,
+		Namespace:      strings.Repeat("n", 253),
+		ServiceAccount: strings.Repeat("s", 253),
+		AppID:          "myapp",
 	})
 
-	kubeAPI2 := kubeAPI(t, kubeAPIOptions{
-		bundle:         bundle,
-		namespace:      strings.Repeat("n", 253),
-		serviceAccount: strings.Repeat("s", 253),
-		appID:          strings.Repeat("a", 65),
+	kubeAPI2 := utils.KubeAPI(t, utils.KubeAPIOptions{
+		Bundle:         bundle,
+		Namespace:      strings.Repeat("n", 253),
+		ServiceAccount: strings.Repeat("s", 253),
+		AppID:          strings.Repeat("a", 65),
 	})
 
-	kubeAPI3 := kubeAPI(t, kubeAPIOptions{
-		bundle:         bundle,
-		namespace:      strings.Repeat("n", 253),
-		serviceAccount: strings.Repeat("s", 253),
-		appID:          strings.Repeat("a", 64),
+	kubeAPI3 := utils.KubeAPI(t, utils.KubeAPIOptions{
+		Bundle:         bundle,
+		Namespace:      strings.Repeat("n", 253),
+		ServiceAccount: strings.Repeat("s", 253),
+		AppID:          strings.Repeat("a", 64),
 	})
 
 	sentryOpts := func(kubeAPI *kubernetes.Kubernetes) *sentry.Sentry {
 		return sentry.New(t,
 			sentry.WithWriteConfig(false),
 			sentry.WithKubeconfig(kubeAPI.KubeconfigPath(t)),
+			sentry.WithMode(string(modes.KubernetesMode)),
 			sentry.WithExecOptions(
 				// Enable Kubernetes validator.
 				exec.WithEnvVars(t, "KUBERNETES_SERVICE_HOST", "anything"),
