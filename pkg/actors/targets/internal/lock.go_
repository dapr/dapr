/*
Copyright 2024 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package internal

import (
	"context"
	"errors"
	"sync"

	invokev1 "github.com/dapr/dapr/pkg/messaging/v1"
	"github.com/dapr/kit/concurrency/fifo"
)

var (
	ErrorMaxStackDepthExceeded = errors.New("maximum stack depth exceeded")
	ErrorLockClosed            = errors.New("actor lock is closed")
)

type LockOptions struct {
	ActorType string
}

type Lock struct {
	actorType string

	reqCh         chan *req
	lock          *fifo.Mutex
	handleReqLock *fifo.Mutex

	stackDepth        int
	maxStackDepth     int
	reentrancyEnabled bool

	inflights []*inflight
	closeCh   chan struct{}
	wg        sync.WaitGroup
}

type req struct {
	msg    *invokev1.InvokeMethodRequest
	locked chan resp
}

type resp struct {
	cancel context.CancelFunc
	err    error
}

type inflight struct {
	id *string
}

//func NewLock(opts LockOptions) *Lock {
//	l := &Lock{
//		actorType:     opts.ActorType,
//		reqCh:         make(chan *req),
//		lock:          fifo.New(),
//		closeCh:       make(chan struct{}),
//		handleReqLock: fifo.New(),
//	}
//
//	l.wg.Add(1)
//	go func() {
//		defer l.wg.Done()
//		for {
//			select {
//			case <-l.closeCh:
//				// Ensure all pending requests are handled before closing.
//				l.LockRequest(nil)
//				return
//			case req := <-l.reqCh:
//				diag.DefaultMonitoring.ReportActorPendingCalls(l.actorType, 1)
//				l.handleReq(req)
//			}
//		}
//	}()
//
//	return l
//}
//
//func (l *Lock) Lock() (context.CancelFunc, error) {
//	return l.LockRequest(nil)
//}
//
//func (l *Lock) LockRequest(msg *invokev1.InvokeMethodRequest) (context.CancelFunc, error) {
//	select {
//	case <-l.closeCh:
//		return nil, ErrorLockClosed
//	default:
//	}
//
//	req := &req{locked: make(chan resp), msg: msg}
//	l.reqCh <- req
//	resp := <-req.locked
//	return resp.cancel, resp.err
//}
//
//func (l *Lock) handleReq(req *req) {
//	l.handleReqLock.Lock()
//
//	if req.msg == nil || !l.reentrancyEnabled {
//		l.handleReqLock.Unlock()
//		l.lock.Lock()
//
//		l.inflight = nil
//		l.stackDepth = 0
//
//		req.locked <- resp{cancel: func() {
//			diag.DefaultMonitoring.ReportActorPendingCalls(l.actorType, -1)
//			l.lock.Unlock()
//		}}
//
//		return
//	}
//
//	id := l.idFromRequest(req.msg)
//
//	if l.inflight != nil && *l.inflight == id {
//		defer l.handleReqLock.Unlock()
//
//		if l.stackDepth == l.maxStackDepth {
//			req.locked <- resp{err: ErrorMaxStackDepthExceeded}
//			return
//		}
//
//		l.stackDepth++
//		req.locked <- resp{cancel: func() {
//			l.handleReqLock.Lock()
//			l.stackDepth--
//			if l.stackDepth == 0 {
//				l.inflight = nil
//				l.lock.Unlock()
//			}
//			l.handleReqLock.Unlock()
//		}}
//		return
//	}
//
//	l.handleReqLock.Unlock()
//	l.lock.Lock()
//
//	l.inflight = &id
//	l.stackDepth = 1
//
//	req.locked <- resp{cancel: func() {
//		l.handleReqLock.Lock()
//		l.stackDepth--
//		if l.stackDepth == 0 {
//			l.inflight = nil
//			l.lock.Unlock()
//		}
//		l.handleReqLock.Unlock()
//	}}
//}
//
//func (l *Lock) idFromRequest(req *invokev1.InvokeMethodRequest) string {
//	if md := req.Metadata()["Dapr-Reentrancy-Id"]; md != nil && len(md.GetValues()) > 0 {
//		return md.GetValues()[0]
//	}
//
//	uuidStr := uuid.New().String()
//	req.AddMetadata(map[string][]string{
//		"Dapr-Reentrancy-Id": {uuidStr},
//	})
//
//	return uuidStr
//}
//
//func (l *Lock) Close() {
//	defer l.wg.Wait()
//	close(l.closeCh)
//}
