// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/proto/sentry/v1/sentry.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SignCertificateRequest struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// A PEM-encoded x509 CSR.
	CertificateSigningRequest []byte   `protobuf:"bytes,3,opt,name=certificate_signing_request,json=certificateSigningRequest,proto3" json:"certificate_signing_request,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *SignCertificateRequest) Reset()         { *m = SignCertificateRequest{} }
func (m *SignCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*SignCertificateRequest) ProtoMessage()    {}
func (*SignCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_05d56fb34d6756c0, []int{0}
}

func (m *SignCertificateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignCertificateRequest.Unmarshal(m, b)
}
func (m *SignCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignCertificateRequest.Marshal(b, m, deterministic)
}
func (m *SignCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignCertificateRequest.Merge(m, src)
}
func (m *SignCertificateRequest) XXX_Size() int {
	return xxx_messageInfo_SignCertificateRequest.Size(m)
}
func (m *SignCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignCertificateRequest proto.InternalMessageInfo

func (m *SignCertificateRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SignCertificateRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SignCertificateRequest) GetCertificateSigningRequest() []byte {
	if m != nil {
		return m.CertificateSigningRequest
	}
	return nil
}

type SignCertificateResponse struct {
	// A PEM-encoded x509 Certificate.
	WorkloadCertificate []byte `protobuf:"bytes,1,opt,name=workload_certificate,json=workloadCertificate,proto3" json:"workload_certificate,omitempty"`
	// A list of PEM-encoded x509 Certificates that establish the trust chain
	// between the workload certificate and the well-known trust root cert.
	TrustChainCertificates [][]byte             `protobuf:"bytes,2,rep,name=trust_chain_certificates,json=trustChainCertificates,proto3" json:"trust_chain_certificates,omitempty"`
	ValidUntil             *timestamp.Timestamp `protobuf:"bytes,3,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}             `json:"-"`
	XXX_unrecognized       []byte               `json:"-"`
	XXX_sizecache          int32                `json:"-"`
}

func (m *SignCertificateResponse) Reset()         { *m = SignCertificateResponse{} }
func (m *SignCertificateResponse) String() string { return proto.CompactTextString(m) }
func (*SignCertificateResponse) ProtoMessage()    {}
func (*SignCertificateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05d56fb34d6756c0, []int{1}
}

func (m *SignCertificateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignCertificateResponse.Unmarshal(m, b)
}
func (m *SignCertificateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignCertificateResponse.Marshal(b, m, deterministic)
}
func (m *SignCertificateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignCertificateResponse.Merge(m, src)
}
func (m *SignCertificateResponse) XXX_Size() int {
	return xxx_messageInfo_SignCertificateResponse.Size(m)
}
func (m *SignCertificateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignCertificateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignCertificateResponse proto.InternalMessageInfo

func (m *SignCertificateResponse) GetWorkloadCertificate() []byte {
	if m != nil {
		return m.WorkloadCertificate
	}
	return nil
}

func (m *SignCertificateResponse) GetTrustChainCertificates() [][]byte {
	if m != nil {
		return m.TrustChainCertificates
	}
	return nil
}

func (m *SignCertificateResponse) GetValidUntil() *timestamp.Timestamp {
	if m != nil {
		return m.ValidUntil
	}
	return nil
}

func init() {
	proto.RegisterType((*SignCertificateRequest)(nil), "pkg.proto.sentry.v1.SignCertificateRequest")
	proto.RegisterType((*SignCertificateResponse)(nil), "pkg.proto.sentry.v1.SignCertificateResponse")
}

func init() { proto.RegisterFile("pkg/proto/sentry/v1/sentry.proto", fileDescriptor_05d56fb34d6756c0) }

var fileDescriptor_05d56fb34d6756c0 = []byte{
	// 330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0x41, 0x4b, 0xc3, 0x30,
	0x18, 0xb5, 0x1d, 0x0a, 0x66, 0x43, 0x21, 0x1b, 0xb3, 0xce, 0x83, 0x65, 0xa7, 0xa2, 0x92, 0xb2,
	0x79, 0x11, 0x04, 0x41, 0xf7, 0x0f, 0x3a, 0xbd, 0x78, 0x29, 0x5d, 0x9b, 0x65, 0xa1, 0x5d, 0x12,
	0x93, 0xaf, 0x13, 0x2f, 0xfe, 0x39, 0xff, 0x98, 0x2c, 0xd9, 0xb0, 0x68, 0x0f, 0x5e, 0xc2, 0x97,
	0xf7, 0xbd, 0xf7, 0xe5, 0xe5, 0x25, 0x28, 0x54, 0x25, 0x8b, 0x95, 0x96, 0x20, 0x63, 0x43, 0x05,
	0xe8, 0x8f, 0x78, 0x33, 0xd9, 0x55, 0xc4, 0xc2, 0xb8, 0xaf, 0x4a, 0xe6, 0x4a, 0xb2, 0xc3, 0x37,
	0x93, 0xd1, 0x25, 0x93, 0x92, 0x55, 0xd4, 0x29, 0x17, 0xf5, 0x32, 0x06, 0xbe, 0xa6, 0x06, 0xb2,
	0xb5, 0x72, 0xd4, 0xf1, 0x27, 0x1a, 0xce, 0x39, 0x13, 0x33, 0xaa, 0x81, 0x2f, 0x79, 0x9e, 0x01,
	0x4d, 0xe8, 0x5b, 0x4d, 0x0d, 0xe0, 0x13, 0xe4, 0xf3, 0x22, 0xf0, 0x42, 0x2f, 0x3a, 0x4e, 0x7c,
	0x5e, 0xe0, 0x01, 0x3a, 0x04, 0x59, 0x52, 0x11, 0xf8, 0x16, 0x72, 0x1b, 0xfc, 0x80, 0x2e, 0xf2,
	0x1f, 0x6d, 0x6a, 0x38, 0x13, 0x5c, 0xb0, 0x54, 0xbb, 0x21, 0x41, 0x27, 0xf4, 0xa2, 0x5e, 0x72,
	0xde, 0xa0, 0xcc, 0x1d, 0x63, 0x77, 0xca, 0xf8, 0xcb, 0x43, 0x67, 0x7f, 0x0c, 0x18, 0x25, 0x85,
	0xa1, 0x78, 0x82, 0x06, 0xef, 0x52, 0x97, 0x95, 0xcc, 0x8a, 0xb4, 0x31, 0xc1, 0x7a, 0xea, 0x25,
	0xfd, 0x7d, 0xaf, 0x21, 0xc5, 0x77, 0x28, 0x00, 0x5d, 0x1b, 0x48, 0xf3, 0x55, 0xc6, 0x45, 0x53,
	0x65, 0x02, 0x3f, 0xec, 0x44, 0xbd, 0x64, 0x68, 0xfb, 0xb3, 0x6d, 0xbb, 0x21, 0x34, 0xf8, 0x1e,
	0x75, 0x37, 0x59, 0xc5, 0x8b, 0xb4, 0x16, 0xc0, 0x2b, 0x6b, 0xbc, 0x3b, 0x1d, 0x11, 0x97, 0x1f,
	0xd9, 0xe7, 0x47, 0x9e, 0xf7, 0xf9, 0x25, 0xc8, 0xd2, 0x5f, 0xb6, 0xec, 0x29, 0x20, 0x7f, 0xf6,
	0x88, 0x05, 0x3a, 0xfd, 0x75, 0x15, 0x7c, 0x4d, 0x5a, 0x5e, 0x85, 0xb4, 0x27, 0x3e, 0xba, 0xf9,
	0x1f, 0xd9, 0xa5, 0x33, 0x3e, 0x78, 0xba, 0x7a, 0x8d, 0x18, 0x87, 0x55, 0xbd, 0x20, 0xb9, 0x5c,
	0xc7, 0x45, 0xa6, 0xb4, 0x5b, 0x5a, 0xbe, 0xca, 0xe2, 0xc8, 0x02, 0xb7, 0xdf, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xfb, 0x5c, 0xa9, 0xb0, 0x48, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CAClient is the client API for CA service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CAClient interface {
	// A request for a time-bound certificate to be signed.
	//
	// The requesting side must provide an id for both loosely based
	// And strong based identities.
	SignCertificate(ctx context.Context, in *SignCertificateRequest, opts ...grpc.CallOption) (*SignCertificateResponse, error)
}

type cAClient struct {
	cc *grpc.ClientConn
}

func NewCAClient(cc *grpc.ClientConn) CAClient {
	return &cAClient{cc}
}

func (c *cAClient) SignCertificate(ctx context.Context, in *SignCertificateRequest, opts ...grpc.CallOption) (*SignCertificateResponse, error) {
	out := new(SignCertificateResponse)
	err := c.cc.Invoke(ctx, "/pkg.proto.sentry.v1.CA/SignCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CAServer is the server API for CA service.
type CAServer interface {
	// A request for a time-bound certificate to be signed.
	//
	// The requesting side must provide an id for both loosely based
	// And strong based identities.
	SignCertificate(context.Context, *SignCertificateRequest) (*SignCertificateResponse, error)
}

// UnimplementedCAServer can be embedded to have forward compatible implementations.
type UnimplementedCAServer struct {
}

func (*UnimplementedCAServer) SignCertificate(ctx context.Context, req *SignCertificateRequest) (*SignCertificateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignCertificate not implemented")
}

func RegisterCAServer(s *grpc.Server, srv CAServer) {
	s.RegisterService(&_CA_serviceDesc, srv)
}

func _CA_SignCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CAServer).SignCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pkg.proto.sentry.v1.CA/SignCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CAServer).SignCertificate(ctx, req.(*SignCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pkg.proto.sentry.v1.CA",
	HandlerType: (*CAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignCertificate",
			Handler:    _CA_SignCertificate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/sentry/v1/sentry.proto",
}
